{
  "id": "coordinate_object",
  "category": "calc",
  "name": "[오브젝트]의 [x/y/방향/이동방향/크기/그림번호/그림이름] 값",
  "description": "특정 오브젝트의 다양한 속성값(위치, 방향, 크기, 그림 정보)을 가져오는 블록입니다. 다른 오브젝트의 상태를 확인하거나 오브젝트 간의 상호작용을 구현할 때 사용합니다.",

  "educational_context": {
    "learning_objectives": [
      "오브젝트의 속성과 상태 정보 이해",
      "오브젝트 간의 정보 공유와 상호작용 학습",
      "프로그램에서 데이터 읽기와 활용 방법 습득",
      "다중 오브젝트 시스템에서의 협업 구조 이해",
      "실시간 상태 감지를 통한 동적 프로그래밍 구현"
    ],
    "key_concepts": [
      {
        "concept": "오브젝트 속성(Object Properties)",
        "explanation": "오브젝트가 가지고 있는 특성이나 상태 정보로, 위치(x, y), 방향, 크기, 모양 등을 포함하며 프로그램 실행 중에 변할 수 있음"
      },
      {
        "concept": "오브젝트 간 통신",
        "explanation": "한 오브젝트가 다른 오브젝트의 정보를 읽어와서 자신의 동작을 결정하는 프로그래밍 패턴"
      },
      {
        "concept": "상태 감지(State Detection)",
        "explanation": "오브젝트의 현재 상태를 실시간으로 확인하여 그에 따른 적절한 반응을 하는 프로그래밍 기법"
      },
      {
        "concept": "좌표계와 각도 시스템",
        "explanation": "오브젝트의 위치를 나타내는 x, y 좌표와 방향을 나타내는 각도 체계에 대한 이해"
      },
      {
        "concept": "동적 데이터 접근",
        "explanation": "실행 중에 변하는 값들을 실시간으로 읽어와서 프로그램 로직에 활용하는 방법"
      }
    ],
    "difficulty_level": "중급",
    "prerequisites": [
      "Entry 기본 인터페이스 사용법",
      "오브젝트와 스프라이트 개념 이해",
      "좌표계와 방향 개념",
      "변수 사용 방법",
      "기본 수학 연산 지식"
    ]
  },

  "usage_examples": [
    {
      "title": "오브젝트 따라가기",
      "description": "한 캐릭터가 다른 캐릭터를 따라 움직임",
      "blocks": [
        "시작 버튼을 클릭했을 때",
        "계속 반복하기",
        "  x좌표를 ([리더]의 x 값)으로 정하기",
        "  y좌표를 ([리더]의 y 값)으로 정하기",
        "  0.1초 기다리기"
      ],
      "explanation": "팔로워 캐릭터가 리더 캐릭터의 위치를 계속 확인하여 같은 위치로 이동합니다."
    },
    {
      "title": "크기 비교 게임",
      "description": "여러 오브젝트의 크기를 비교하여 점수 계산",
      "blocks": [
        "시작 버튼을 클릭했을 때",
        "'스페이스를 눌러 크기를 비교하세요!' 말하기",
        "스페이스 키를 눌렀을 때까지 기다리기",
        "만약 ([캐릭터A]의 크기 값) > ([캐릭터B]의 크기 값) 라면",
        "  '캐릭터A가 더 큽니다!' 말하기",
        "  점수 변수를 10만큼 바꾸기",
        "아니라면",
        "  '캐릭터B가 더 큽니다!' 말하기"
      ],
      "explanation": "두 캐릭터의 크기를 비교하여 결과를 알려주고 점수를 계산하는 게임입니다."
    },
    {
      "title": "거리 기반 상호작용",
      "description": "오브젝트 간의 거리에 따른 다른 반응",
      "blocks": [
        "시작 버튼을 클릭했을 때",
        "계속 반복하기",
        "  거리 변수를 (([목표]의 x 값) - (이 캐릭터의 x 값))의 절댓값으로 정하기",
        "  만약 (거리) < (50) 라면",
        "    크기를 150으로 정하기",
        "    '가까워졌어요!' 말하기",
        "  아니라면",
        "    크기를 100으로 정하기",
        "  0.2초 기다리기"
      ],
      "explanation": "목표 오브젝트에 가까워지면 캐릭터가 커지고 메시지를 출력합니다."
    },
    {
      "title": "그림 변화 감지",
      "description": "다른 오브젝트의 그림 변화를 감지하여 반응",
      "blocks": [
        "시작 버튼을 클릭했을 때",
        "이전그림 변수를 ([신호등]의 그림이름 값)으로 정하기",
        "계속 반복하기",
        "  현재그림 변수를 ([신호등]의 그림이름 값)으로 정하기",
        "  만약 (현재그림) ≠ (이전그림) 라면",
        "    만약 (현재그림) = ('빨간불') 라면",
        "      '멈춰!' 말하기",
        "    아니라면",
        "      '가세요!' 말하기",
        "    이전그림 변수를 (현재그림)으로 정하기",
        "  0.1초 기다리기"
      ],
      "explanation": "신호등 오브젝트의 그림이 바뀔 때마다 적절한 메시지를 출력하는 시스템입니다."
    },
    {
      "title": "회전 동기화",
      "description": "한 오브젝트의 회전에 따라 다른 오브젝트도 회전",
      "blocks": [
        "시작 버튼을 클릭했을 때",
        "계속 반복하기",
        "  주인방향 변수를 ([주인]의 방향 값)으로 정하기",
        "  회전 방향을 (주인방향) + (90)으로 정하기",
        "  0.05초 기다리기"
      ],
      "explanation": "주인 오브젝트의 방향을 따라가되, 90도 돌린 방향으로 회전하는 위성 오브젝트를 만듭니다."
    }
  ],

  "progressive_hints": [
    {
      "situation": "다른 오브젝트의 정보를 어떻게 가져오나요?",
      "steps": [
        {
          "step": 1,
          "hint_type": "category",
          "content": "'계산' 카테고리(초록색 계산기 모양 아이콘)를 클릭해보세요"
        },
        {
          "step": 2,
          "hint_type": "specific_block",
          "content": "'[오브젝트]의 [속성] 값' 블록을 찾아보세요"
        },
        {
          "step": 3,
          "hint_type": "concept",
          "content": "첫 번째 드롭다운에서 정보를 가져올 오브젝트를 선택하고, 두 번째 드롭다운에서 원하는 속성을 선택하세요"
        }
      ]
    },
    {
      "situation": "오브젝트가 따라가도록 만들고 싶어요",
      "steps": [
        {
          "step": 1,
          "hint_type": "concept",
          "content": "계속 반복하기 블록으로 실시간으로 다른 오브젝트의 위치를 확인해야 해요"
        },
        {
          "step": 2,
          "hint_type": "specific_block",
          "content": "오브젝트의 x값과 y값을 각각 가져와서 자신의 위치로 설정하세요"
        },
        {
          "step": 3,
          "hint_type": "category",
          "content": "'움직임' 카테고리의 위치 설정 블록과 함께 사용하세요"
        }
      ]
    },
    {
      "situation": "오브젝트 간의 거리를 계산하고 싶어요",
      "steps": [
        {
          "step": 1,
          "hint_type": "concept",
          "content": "두 오브젝트의 x좌표와 y좌표를 각각 가져와야 해요"
        },
        {
          "step": 2,
          "hint_type": "specific_block",
          "content": "피타고라스 정리를 사용하거나 '~까지의 거리' 블록을 활용하세요"
        },
        {
          "step": 3,
          "hint_type": "category",
          "content": "계산 블록으로 (x차이)² + (y차이)²의 제곱근을 구할 수 있어요"
        }
      ]
    }
  ],

  "common_mistakes": [
    {
      "mistake": "자기 자신의 속성을 확인할 때도 오브젝트명을 지정",
      "why_it_happens": "'이 오브젝트' 옵션이 있다는 것을 모르고 복잡하게 오브젝트명을 찾으려 함",
      "consequence": "불필요하게 복잡한 코드 작성",
      "solution": "자기 자신의 속성을 확인할 때는 '이 오브젝트' 또는 '이 캐릭터' 옵션 사용",
      "teaching_moment": "자기 자신을 가리킬 때는 '나'라고 하는 것처럼, 프로그래밍에서도 '이 오브젝트'라는 특별한 표현이 있어요."
    },
    {
      "mistake": "속성값을 한 번만 가져와서 변수에 저장 후 계속 사용",
      "why_it_happens": "오브젝트의 속성이 실시간으로 변한다는 것을 이해하지 못함",
      "consequence": "오브젝트가 움직이거나 변해도 프로그램이 반응하지 않음",
      "solution": "속성값이 필요할 때마다 매번 새로 가져오거나, 반복문 안에서 지속적으로 업데이트",
      "teaching_moment": "친구의 위치를 알고 싶으면 한 번 물어보고 끝이 아니라 계속 확인해야 하는 것과 같아요."
    },
    {
      "mistake": "방향과 회전 값을 혼동",
      "why_it_happens": "방향(direction)과 회전(rotation)의 차이를 정확히 구분하지 못함",
      "consequence": "예상과 다른 각도값이 나와서 회전 관련 계산에 오류 발생",
      "solution": "방향은 이동할 방향, 회전은 오브젝트가 돌아간 각도라는 차이점 이해",
      "teaching_moment": "'어디로 갈 것인가'와 '얼마나 돌았는가'는 다른 개념이에요. 방향은 목적지, 회전은 몸의 각도예요."
    },
    {
      "mistake": "그림번호와 그림이름을 적절히 활용하지 못함",
      "why_it_happens": "숫자(그림번호)와 문자(그림이름) 중 어떤 것을 사용할지 판단하지 못함",
      "consequence": "그림 변화 감지나 조건 확인에서 의도하지 않은 결과",
      "solution": "숫자로 비교할 때는 그림번호, 문자로 비교할 때는 그림이름 사용",
      "teaching_moment": "사람을 '1번'으로 부르는 것과 '김철수'로 부르는 것이 다르듯, 그림도 번호와 이름 두 가지 방법으로 구분할 수 있어요."
    }
  ],

  "step_by_step_guide": [
    {
      "step": 1,
      "title": "계산 블록 찾기",
      "instruction": "블록 팔레트에서 '계산' 카테고리(초록색 계산기 모양)를 클릭하세요.",
      "visual_hint": "초록색 아이콘이고 계산기나 숫자 모양을 하고 있어요."
    },
    {
      "step": 2,
      "title": "오브젝트 속성 블록 선택",
      "instruction": "'[오브젝트]의 [속성] 값' 블록을 찾아서 작업 영역으로 드래그하세요.",
      "visual_hint": "둥근 모양의 블록으로 두 개의 드롭다운 메뉴가 있어요."
    },
    {
      "step": 3,
      "title": "대상 오브젝트 선택",
      "instruction": "첫 번째 드롭다운에서 정보를 가져올 오브젝트를 선택하세요.",
      "visual_hint": "프로젝트에 있는 모든 오브젝트 목록과 '이 오브젝트' 옵션이 나타나요."
    },
    {
      "step": 4,
      "title": "속성 유형 선택",
      "instruction": "두 번째 드롭다운에서 원하는 속성(x, y, 방향, 크기 등)을 선택하세요.",
      "visual_hint": "x, y, 방향, 이동방향, 크기, 그림번호, 그림이름 중에서 선택할 수 있어요."
    },
    {
      "step": 5,
      "title": "속성값 활용",
      "instruction": "완성된 속성 블록을 변수에 저장하거나 다른 블록의 입력으로 사용하세요.",
      "visual_hint": "둥근 모양의 속성 블록은 숫자나 문자가 들어갈 자리에 넣을 수 있어요."
    },
    {
      "step": 6,
      "title": "실시간 업데이트 설정",
      "instruction": "속성값이 변할 수 있다면 반복 블록 안에서 계속 확인하도록 설정하세요.",
      "visual_hint": "오브젝트가 움직이거나 변하는 경우 실시간으로 값을 확인해야 해요."
    }
  ],

  "related_blocks": [
    {
      "block_id": "coordinate_mouse",
      "block_name": "마우스 포인터의 [x/y] 좌표",
      "relationship": "위치 정보 비교",
      "explanation": "마우스 위치와 오브젝트 위치를 비교하여 상호작용 구현"
    },
    {
      "block_id": "distance_something",
      "block_name": "[오브젝트/마우스]까지의 거리",
      "relationship": "거리 계산 단순화",
      "explanation": "복잡한 거리 계산 없이 직접 거리값을 구할 수 있는 편리한 블록"
    },
    {
      "block_id": "locate_xy",
      "block_name": "x: [x값], y: [y값] 위치로 이동하기",
      "relationship": "위치 정보 활용",
      "explanation": "다른 오브젝트의 위치 정보를 사용하여 이동 명령 실행"
    },
    {
      "block_id": "boolean_basic_operator",
      "block_name": "[~] [비교연산자] [~]",
      "relationship": "속성값 비교",
      "explanation": "오브젝트의 속성값을 다른 값과 비교하여 조건 판단에 활용"
    },
    {
      "block_id": "set_variable",
      "block_name": "[변수]를 [값]으로 정하기",
      "relationship": "속성값 저장",
      "explanation": "오브젝트의 속성값을 변수에 저장하여 나중에 참조하거나 계산에 사용"
    },
    {
      "block_id": "_if",
      "block_name": "만약 ~라면",
      "relationship": "조건부 실행",
      "explanation": "오브젝트의 속성값에 따라 다른 동작을 수행하는 조건문에서 활용"
    },
    {
      "block_id": "repeat_inf",
      "block_name": "계속 반복하기",
      "relationship": "실시간 감지",
      "explanation": "오브젝트의 속성 변화를 지속적으로 감지하고 반응하기 위해 함께 사용"
    }
  ],

  "debugging_tips": [
    {
      "problem": "오브젝트 이름을 선택할 수 없어요",
      "possible_causes": [
        "해당 오브젝트가 프로젝트에 존재하지 않음",
        "오브젝트 이름을 잘못 기억하거나 철자 오류",
        "오브젝트가 숨겨져 있거나 삭제됨"
      ],
      "solutions": [
        "오브젝트 목록에서 실제 존재하는 오브젝트 이름 확인",
        "오브젝트 패널에서 오브젝트가 제대로 추가되어 있는지 점검",
        "오브젝트 이름을 정확히 입력했는지 확인"
      ]
    },
    {
      "problem": "속성값이 예상과 달라요",
      "possible_causes": [
        "잘못된 속성을 선택함",
        "오브젝트의 초기값과 현재값이 다름",
        "속성값을 한 번만 가져와서 업데이트되지 않음"
      ],
      "solutions": [
        "원하는 속성(x, y, 방향, 크기 등)을 정확히 선택했는지 확인",
        "속성값을 화면에 출력해서 실제 값 확인",
        "반복문 안에서 매번 새로운 속성값을 가져오도록 설정"
      ]
    },
    {
      "problem": "오브젝트 간 상호작용이 작동하지 않아요",
      "possible_causes": [
        "속성값 비교 조건이 잘못됨",
        "실시간 업데이트가 이루어지지 않음",
        "오브젝트가 예상한 위치나 상태가 아님"
      ],
      "solutions": [
        "조건문에서 사용하는 비교 연산자와 값 재확인",
        "각 오브젝트의 현재 상태를 별도로 출력해서 확인",
        "오브젝트들이 실제로 변하고 있는지 시각적으로 확인"
      ]
    }
  ],

  "real_world_connections": [
    {
      "analogy": "스포츠 중계",
      "explanation": "축구 중계에서 선수의 위치나 속도를 실시간으로 확인하는 것처럼, 오브젝트의 속성을 실시간으로 감지합니다."
    },
    {
      "analogy": "교통 관제 시스템",
      "explanation": "교통 관제소에서 각 차량의 위치와 속도를 모니터링하는 것처럼, 여러 오브젝트의 상태를 동시에 추적할 수 있습니다."
    },
    {
      "analogy": "로봇 팀워크",
      "explanation": "로봇들이 서로의 위치를 확인하며 협력하는 것처럼, 오브젝트들이 서로의 정보를 공유하며 상호작용합니다."
    },
    {
      "analogy": "댄스 안무",
      "explanation": "댄서들이 서로의 동작을 보고 맞춰 춤추는 것처럼, 오브젝트들이 서로의 상태에 따라 반응하며 조화로운 움직임을 만듭니다."
    }
  ],

  "extensions_and_variations": [
    {
      "concept": "다중 오브젝트 추적 시스템",
      "description": "여러 오브젝트의 속성을 동시에 모니터링하고 통계나 평균값을 계산하는 시스템",
      "use_case": "무리 시뮬레이션, 성과 모니터링 시스템"
    },
    {
      "concept": "적응형 AI 행동",
      "description": "다른 오브젝트의 행동 패턴을 분석하여 자신의 행동을 조정하는 지능형 시스템",
      "use_case": "게임 AI, 자동 추적 시스템"
    },
    {
      "concept": "물리 시뮬레이션",
      "description": "오브젝트들의 위치와 속도 정보를 활용한 현실적인 물리 효과 구현",
      "use_case": "중력 시뮬레이션, 충돌 반응 시스템"
    },
    {
      "concept": "데이터 시각화",
      "description": "오브젝트의 속성값 변화를 그래프나 차트로 실시간 표시",
      "use_case": "성능 모니터링, 상태 대시보드"
    }
  ],

  "assessment_criteria": [
    {
      "level": "기초",
      "criteria": "다른 오브젝트의 기본 속성을 가져와서 간단한 상호작용을 구현할 수 있다",
      "example": "오브젝트 따라가기, 크기 비교"
    },
    {
      "level": "중급",
      "criteria": "여러 오브젝트의 속성을 조합하여 복잡한 상호작용 시스템을 만들 수 있다",
      "example": "거리 기반 게임, 그림 변화 감지 시스템"
    },
    {
      "level": "고급",
      "criteria": "오브젝트 속성을 활용한 고급 알고리즘과 시뮬레이션을 설계할 수 있다",
      "example": "무리 행동 시뮬레이션, 적응형 AI 시스템"
    }
  ]
}
