{
  "id": "stop_object",
  "category": "flow",
  "name": "이 오브젝트의 다른 스크립트 멈추기",
  "description": "현재 오브젝트에서 실행 중인 다른 모든 스크립트(코드 묶음)를 중지시키는 블록입니다. 이 블록을 포함한 현재 스크립트는 계속 실행되며, 같은 오브젝트의 다른 이벤트나 반복문만 멈춥니다.",

  "educational_context": {
    "learning_objectives": [
      "오브젝트별 스크립트 제어 개념 이해",
      "병렬 실행과 선택적 중단 방법 학습",
      "스크립트 간 충돌 해결 기법 습득",
      "효율적인 코드 관리와 제어 능력 개발",
      "이벤트 기반 프로그래밍의 흐름 제어 이해"
    ],
    "key_concepts": [
      {
        "concept": "스크립트 제어",
        "explanation": "하나의 오브젝트에서 동시에 실행되는 여러 스크립트 중 특정 스크립트만 남기고 나머지를 중단하는 기능입니다."
      },
      {
        "concept": "선택적 중단",
        "explanation": "현재 실행 중인 스크립트는 유지하면서 같은 오브젝트의 다른 스크립트만 멈추는 선택적 제어입니다."
      },
      {
        "concept": "오브젝트 범위",
        "explanation": "이 블록은 현재 오브젝트에만 영향을 주며, 다른 오브젝트의 스크립트는 계속 실행됩니다."
      },
      {
        "concept": "동시 실행 관리",
        "explanation": "여러 이벤트가 동시에 발생할 때 우선순위를 정하고 충돌을 방지하는 제어 방법입니다."
      }
    ],
    "difficulty_level": "중급",
    "prerequisites": ["이벤트 블록 사용 경험", "여러 스크립트 작성 경험", "오브젝트 개념 이해", "프로그램 흐름 제어 기초"]
  },

  "usage_examples": [
    {
      "title": "애니메이션 전환",
      "description": "새 애니메이션 시작 시 이전 애니메이션 중단",
      "blocks": [
        "when_some_key_pressed('1')",
        "stop_object",
        "speak_something('걷기 애니메이션')",
        "repeat_while_true",
        "  change_to_next_shape",
        "  wait_second(0.1)",
        "",
        "when_some_key_pressed('2')",
        "stop_object",
        "speak_something('뛰기 애니메이션')",
        "repeat_while_true",
        "  change_to_next_shape",
        "  wait_second(0.05)",
        "",
        "when_some_key_pressed('3')",
        "stop_object",
        "speak_something('점프 애니메이션')",
        "repeat_basic(5)",
        "  change_y(20)",
        "  wait_second(0.1)",
        "repeat_basic(5)",
        "  change_y(-20)",
        "  wait_second(0.1)"
      ],
      "explanation": "새로운 애니메이션 키를 누르면 이전 애니메이션을 중단하고 새 애니메이션을 시작합니다."
    },
    {
      "title": "상태 전환 시스템",
      "description": "게임 상태 변경 시 이전 상태 중단",
      "blocks": [
        "when_message_cast('대기상태')",
        "stop_object",
        "set_variable('상태', '대기')",
        "repeat_while_true(<get_variable('상태') = '대기'>)",
        "  set_transparency(50)",
        "  wait_second(0.5)",
        "  set_transparency(100)",
        "  wait_second(0.5)",
        "",
        "when_message_cast('공격상태')",
        "stop_object",
        "set_variable('상태', '공격')",
        "speak_something('공격!')",
        "repeat_basic(3)",
        "  move_direction(50)",
        "  wait_second(0.1)",
        "  move_direction(-50)",
        "  wait_second(0.1)",
        "broadcast_message('대기상태')"
      ],
      "explanation": "메시지에 따라 상태를 전환하며, 새 상태 시작 시 이전 상태의 스크립트를 중단합니다."
    },
    {
      "title": "우선순위 이벤트",
      "description": "긴급 이벤트 발생 시 다른 동작 중단",
      "blocks": [
        "when_run_button_click",
        "repeat_while_true",
        "  move_to_random_position",
        "  wait_second(2)",
        "",
        "when_object_click",
        "stop_object",
        "speak_something('긴급 정지!')",
        "set_color('#FF0000')",
        "wait_second(2)",
        "set_color('#000000')",
        "speak_something('정상 작동 재개')",
        "broadcast_message('재시작')",
        "",
        "when_message_cast('재시작')",
        "repeat_while_true",
        "  move_to_random_position",
        "  wait_second(2)"
      ],
      "explanation": "클릭 시 긴급 정지로 모든 다른 동작을 중단하고 우선 처리합니다."
    },
    {
      "title": "메뉴 시스템",
      "description": "메뉴 선택 시 이전 메뉴 동작 중단",
      "blocks": [
        "when_message_cast('메인메뉴')",
        "stop_object",
        "show",
        "set_text('메인 메뉴')",
        "repeat_while_true",
        "  if_condition(<is_clicked>)",
        "    broadcast_message('게임시작')",
        "    break",
        "",
        "when_message_cast('게임시작')",
        "stop_object",
        "set_text('게임 진행 중...')",
        "set_variable('게임중', 1)",
        "repeat_while_true(<get_variable('게임중') = 1>)",
        "  // 게임 로직",
        "  if_condition(<key_pressed('esc')>)",
        "    broadcast_message('메인메뉴')",
        "    break"
      ],
      "explanation": "메뉴 전환 시 이전 메뉴의 스크립트를 중단하여 깔끔한 전환을 구현합니다."
    }
  ],

  "progressive_hints": [
    {
      "situation": "같은 오브젝트의 다른 스크립트를 멈추고 싶어요",
      "steps": [
        {
          "step": 1,
          "hint_type": "category",
          "content": "'흐름' 카테고리에서 중단 관련 블록을 찾아보세요"
        },
        {
          "step": 2,
          "hint_type": "specific_block",
          "content": "'이 오브젝트의 다른 스크립트 멈추기' 블록을 사용하세요"
        },
        {
          "step": 3,
          "hint_type": "concept",
          "content": "현재 스크립트는 계속 실행되고 다른 스크립트만 멈춰요"
        }
      ]
    },
    {
      "situation": "애니메이션이 겹쳐서 이상해요",
      "steps": [
        {
          "step": 1,
          "hint_type": "concept",
          "content": "새 애니메이션 시작 전에 이전 것을 멈춰야 해요"
        },
        {
          "step": 2,
          "hint_type": "specific_block",
          "content": "각 애니메이션 시작 부분에 stop_object를 추가하세요"
        },
        {
          "step": 3,
          "hint_type": "category",
          "content": "상태 변수로 현재 애니메이션을 관리하면 더 좋아요"
        }
      ]
    },
    {
      "situation": "우선순위가 높은 이벤트를 만들고 싶어요",
      "steps": [
        {
          "step": 1,
          "hint_type": "concept",
          "content": "중요한 이벤트에서 다른 스크립트를 멈추면 우선순위를 만들 수 있어요"
        },
        {
          "step": 2,
          "hint_type": "category",
          "content": "긴급 이벤트 시작 시 stop_object로 다른 동작 중단"
        },
        {
          "step": 3,
          "hint_type": "specific_block",
          "content": "처리 후 필요하면 메시지로 정상 동작 재개"
        }
      ]
    }
  ],

  "common_mistakes": [
    {
      "mistake": "모든 오브젝트가 멈출 것으로 기대",
      "why_it_happens": "블록의 범위를 잘못 이해",
      "consequence": "다른 오브젝트는 계속 실행됨",
      "solution": "현재 오브젝트에만 영향을 준다는 것을 이해",
      "teaching_moment": "이 블록은 '이 오브젝트'의 스크립트만 멈춰요. 다른 오브젝트는 영향 없어요."
    },
    {
      "mistake": "현재 스크립트도 멈출 것으로 기대",
      "why_it_happens": "'다른' 스크립트의 의미를 놓침",
      "consequence": "현재 스크립트는 계속 실행됨",
      "solution": "현재 스크립트는 제외된다는 것을 인식",
      "teaching_moment": "이 블록을 실행한 스크립트는 계속 진행돼요. '다른' 스크립트만 멈춰요."
    },
    {
      "mistake": "멈춘 스크립트가 자동으로 재시작될 것으로 기대",
      "why_it_happens": "일시정지와 정지를 혼동",
      "consequence": "멈춘 스크립트는 다시 시작되지 않음",
      "solution": "재시작하려면 이벤트를 다시 발생시켜야 함",
      "teaching_moment": "멈춘 스크립트는 완전히 종료돼요. 다시 시작하려면 이벤트가 필요해요."
    },
    {
      "mistake": "순서를 고려하지 않고 사용",
      "why_it_happens": "실행 순서의 중요성을 모름",
      "consequence": "필요한 초기화가 완료되지 않음",
      "solution": "stop_object 전에 필요한 설정 완료",
      "teaching_moment": "다른 스크립트를 멈추기 전에 필요한 설정을 먼저 하세요."
    }
  ],

  "step_by_step_guide": [
    {
      "step": 1,
      "title": "흐름 카테고리 찾기",
      "instruction": "블록 팔레트에서 주황색 '흐름' 카테고리를 클릭하세요.",
      "visual_hint": "화살표 모양의 아이콘이 있는 주황색 카테고리입니다."
    },
    {
      "step": 2,
      "title": "stop_object 블록 선택",
      "instruction": "'이 오브젝트의 다른 스크립트 멈추기' 블록을 찾아서 드래그하세요.",
      "visual_hint": "단독으로 사용되는 제어 블록입니다."
    },
    {
      "step": 3,
      "title": "적절한 위치에 배치",
      "instruction": "새로운 동작을 시작하기 전, 보통 스크립트 시작 부분에 배치하세요.",
      "visual_hint": "이벤트 블록 바로 다음에 배치하는 경우가 많습니다."
    },
    {
      "step": 4,
      "title": "후속 동작 추가",
      "instruction": "stop_object 다음에 실행할 새로운 동작을 추가하세요.",
      "visual_hint": "다른 스크립트가 멈춘 후 실행될 코드를 작성합니다."
    },
    {
      "step": 5,
      "title": "테스트 및 확인",
      "instruction": "여러 이벤트를 발생시켜 스크립트가 올바르게 전환되는지 확인하세요.",
      "visual_hint": "이전 동작이 멈추고 새 동작만 실행되는지 확인합니다."
    }
  ],

  "related_blocks": [
    {
      "block_id": "stop_all",
      "relationship": "전체 중단",
      "explanation": "모든 오브젝트의 모든 스크립트를 중단"
    },
    {
      "block_id": "stop_this_script",
      "relationship": "현재 중단",
      "explanation": "현재 실행 중인 스크립트만 중단"
    },
    {
      "block_id": "broadcast_message",
      "relationship": "재시작 트리거",
      "explanation": "멈춘 동작을 다시 시작하기 위한 이벤트 발생"
    },
    {
      "block_id": "when_message_cast",
      "relationship": "이벤트 수신",
      "explanation": "새로운 동작을 시작하는 이벤트 블록"
    },
    {
      "block_id": "set_variable",
      "relationship": "상태 관리",
      "explanation": "스크립트 상태를 추적하고 관리"
    },
    {
      "block_id": "if_condition",
      "relationship": "조건부 중단",
      "explanation": "특정 조건에서만 다른 스크립트 중단"
    }
  ],

  "debugging_tips": [
    {
      "problem": "다른 오브젝트도 멈춰요",
      "possible_causes": ["stop_all 블록과 혼동", "여러 오브젝트에서 실행", "메시지 브로드캐스트 영향"],
      "solutions": ["stop_object는 현재 오브젝트만 영향", "각 오브젝트별로 개별 처리", "블록 종류 재확인"]
    },
    {
      "problem": "스크립트가 멈추지 않아요",
      "possible_causes": ["다른 오브젝트의 스크립트", "이미 종료된 스크립트", "새로 시작된 스크립트"],
      "solutions": ["같은 오브젝트인지 확인", "실행 중인 스크립트 확인", "타이밍 조정"]
    },
    {
      "problem": "원하는 동작이 실행되지 않아요",
      "possible_causes": ["stop_object가 현재 스크립트도 멈춘 것으로 오해", "후속 코드 작성 누락", "조건문 로직 오류"],
      "solutions": ["stop_object 후 코드는 정상 실행됨 확인", "필요한 동작 코드 추가", "실행 흐름 재점검"]
    }
  ],

  "real_world_connections": [
    {
      "analogy": "TV 채널 변경",
      "explanation": "새 채널로 바꾸면 이전 채널의 프로그램은 보이지 않는 것과 같습니다."
    },
    {
      "analogy": "작업 전환",
      "explanation": "새로운 일을 시작할 때 하던 일을 멈추고 집중하는 것과 비슷합니다."
    },
    {
      "analogy": "앱 전환",
      "explanation": "스마트폰에서 새 앱을 실행하면 이전 앱이 백그라운드로 가는 것과 유사합니다."
    },
    {
      "analogy": "신호등 전환",
      "explanation": "한 방향이 초록불이 되면 다른 방향은 빨간불이 되는 것과 같은 원리입니다."
    }
  ],

  "extensions_and_variations": [
    {
      "concept": "상태 머신 구현",
      "description": "명확한 상태 전환과 스크립트 관리 시스템",
      "use_case": "캐릭터 AI, 게임 상태 관리, UI 전환"
    },
    {
      "concept": "우선순위 시스템",
      "description": "중요도에 따른 스크립트 실행 제어",
      "use_case": "긴급 이벤트, 인터럽트 처리, 멀티태스킹"
    },
    {
      "concept": "스크립트 큐 관리",
      "description": "순차적으로 스크립트를 실행하고 관리",
      "use_case": "컷신 시퀀스, 튜토리얼 진행, 이벤트 체인"
    },
    {
      "concept": "동적 스크립트 제어",
      "description": "실행 중 조건에 따라 스크립트를 선택적으로 제어",
      "use_case": "적응형 AI, 동적 난이도, 컨텍스트 기반 동작"
    }
  ],

  "assessment_criteria": [
    {
      "level": "기초",
      "criteria": "stop_object 블록을 사용해서 스크립트 충돌을 방지할 수 있다",
      "example": "간단한 애니메이션 전환, 상태 변경"
    },
    {
      "level": "중급",
      "criteria": "여러 이벤트와 스크립트를 체계적으로 관리할 수 있다",
      "example": "메뉴 시스템, 상태 머신, 우선순위 이벤트"
    },
    {
      "level": "고급",
      "criteria": "복잡한 스크립트 제어 시스템을 설계하고 구현할 수 있다",
      "example": "다중 상태 관리, 인터럽트 시스템, 동적 스크립트 제어"
    }
  ]
}
