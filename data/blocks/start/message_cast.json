{
  "id": "message_cast",
  "category": "start",
  "name": "신호 보내기",
  "description": "다른 오브젝트들에게 신호(메시지)를 보내는 블록입니다. 이 신호를 받도록 설정된 모든 오브젝트가 동시에 반응하게 할 수 있습니다.",

  "educational_context": {
    "learning_objectives": ["오브젝트 간 통신 시작점 이해", "브로드캐스트 메시징 시스템 학습", "이벤트 트리거 메커니즘 습득"],
    "key_concepts": [
      {
        "concept": "메시지 브로드캐스팅",
        "explanation": "하나의 신호를 여러 오브젝트에게 동시에 전달하는 통신 방식"
      },
      {
        "concept": "이벤트 트리거",
        "explanation": "다른 오브젝트의 동작을 시작시키는 신호를 발생시키는 것"
      },
      {
        "concept": "비동기 통신",
        "explanation": "신호를 보낸 후 받는 쪽의 처리를 기다리지 않고 다음 동작 계속 실행"
      },
      {
        "concept": "디커플링",
        "explanation": "오브젝트들이 서로 직접 알지 못해도 신호를 통해 상호작용할 수 있게 하는 것"
      }
    ],
    "difficulty_level": "중급",
    "prerequisites": ["신호 받기 블록 이해", "여러 오브젝트 관리 경험", "프로그램 흐름 제어 개념"]
  },

  "usage_examples": [
    {
      "title": "게임 시작 신호 발송",
      "description": "시작 버튼을 누르면 모든 게임 요소들이 활성화",
      "blocks": ["when_run_button_click", "message_cast('게임시작')", "speak_something('게임이 시작되었습니다!')"],
      "explanation": "프로그램이 시작되면 '게임시작' 신호를 보내서 모든 캐릭터와 UI가 동시에 활성화됩니다."
    },
    {
      "title": "상태 변화 알림",
      "description": "점수가 올라가면 모든 관련 요소들에게 알림",
      "blocks": ["change_variable_by('score', 10)", "message_cast('점수변경')", "wait_second(0.1)"],
      "explanation": "점수를 올린 후 '점수변경' 신호를 보내서 점수판, 효과음, 애니메이션 등이 모두 업데이트됩니다."
    },
    {
      "title": "순차 실행 제어",
      "description": "한 캐릭터의 동작이 끝나면 다음 캐릭터에게 차례 넘김",
      "blocks": ["move_direction('right', 100)", "message_cast('다음차례')", "hide()"],
      "explanation": "자신의 이동이 끝나면 '다음차례' 신호를 보내고 숨어서 다른 캐릭터가 동작하도록 합니다."
    }
  ],

  "socratic_questions": [
    {
      "level": "이해",
      "question": "신호를 보내면 받는 쪽에서 언제 반응하나요? 즉시 반응할까요?",
      "purpose": "비동기 통신의 특성 이해",
      "follow_up": "신호를 보낸 후 바로 다음 블록이 실행되는 이유는 무엇일까요?"
    },
    {
      "level": "분석",
      "question": "만약 신호를 받을 오브젝트가 아무것도 없다면 어떻게 될까요?",
      "purpose": "통신 시스템의 견고성 이해",
      "follow_up": "이런 상황을 어떻게 방지하거나 처리할 수 있을까요?"
    },
    {
      "level": "적용",
      "question": "멀티플레이어 턴제 게임을 만든다면 신호를 어떻게 활용해서 턴을 관리할까요?",
      "purpose": "복잡한 게임 로직에서의 활용 방안 탐색",
      "follow_up": "플레이어가 중간에 나가거나 들어올 때는 어떻게 처리해야 할까요?"
    }
  ],

  "common_mistakes": [
    {
      "mistake": "신호 이름을 받는 쪽과 다르게 설정",
      "why_it_happens": "여러 곳에서 비슷한 기능을 만들 때 이름을 통일하지 않음",
      "consequence": "신호가 전달되지 않아 기능이 작동하지 않음",
      "solution": "신호 이름을 프로젝트 시작 전에 계획하고 문서화",
      "teaching_moment": "친구들과 만날 때 약속 장소를 정확히 말해야 하는 것처럼, 신호 이름도 정확해야 해요."
    },
    {
      "mistake": "필요 없는 곳에서 신호 남발",
      "why_it_happens": "모든 동작을 신호로 제어하려고 시도",
      "consequence": "프로그램이 복잡해지고 디버깅이 어려워짐",
      "solution": "꼭 필요한 경우에만 신호를 사용하고 단순한 것은 직접 제어",
      "teaching_moment": "모든 말을 확성기로 할 필요는 없듯이, 간단한 것은 직접 처리하는 게 좋아요."
    },
    {
      "mistake": "신호 보내기만 하고 받는 쪽 구현 누락",
      "why_it_happens": "송신 부분만 구현하고 수신 부분을 잊어버림",
      "consequence": "신호를 보내도 아무 반응이 없음",
      "solution": "신호를 보내는 곳과 받는 곳을 쌍으로 설계하고 체크리스트 작성",
      "teaching_moment": "편지를 보내려면 받을 사람이 있어야 하는 것처럼, 신호도 받을 준비가 되어있어야 해요."
    }
  ],

  "step_by_step_guide": [
    {
      "step": 1,
      "title": "신호 설계하기",
      "instruction": "어떤 신호를 언제 보낼지, 누가 받을지 계획을 세우세요.",
      "visual_hint": "종이에 신호의 흐름을 그려보면 도움이 됩니다."
    },
    {
      "step": 2,
      "title": "송신 오브젝트 선택",
      "instruction": "신호를 보낼 오브젝트를 선택하세요.",
      "visual_hint": "보통 게임 매니저나 주요 컨트롤러 역할의 오브젝트입니다."
    },
    {
      "step": 3,
      "title": "신호 카테고리 선택",
      "instruction": "블록 팔레트에서 '신호' 카테고리를 클릭하세요.",
      "visual_hint": "주황색 신호 아이콘이 있는 카테고리입니다."
    },
    {
      "step": 4,
      "title": "신호 보내기 블록 찾기",
      "instruction": "'신호 보내기' 블록을 찾아 클릭하세요.",
      "visual_hint": "방송 아이콘이나 신호를 보내는 모양의 블록입니다."
    },
    {
      "step": 5,
      "title": "신호 이름 설정",
      "instruction": "드롭다운에서 보낼 신호 이름을 선택하거나 새로 만드세요.",
      "visual_hint": "의미가 명확하고 받는 쪽과 일치하는 이름을 사용하세요."
    },
    {
      "step": 6,
      "title": "적절한 위치에 배치",
      "instruction": "신호를 보내야 하는 시점에 맞춰 다른 블록들과 연결하세요.",
      "visual_hint": "조건문 안이나 특정 동작 후에 배치하는 경우가 많습니다."
    },
    {
      "step": 7,
      "title": "수신 쪽 확인",
      "instruction": "신호를 받을 오브젝트들에서 '신호를 받았을 때' 블록이 준비되었는지 확인하세요.",
      "visual_hint": "모든 관련 오브젝트에서 같은 신호 이름으로 설정되어 있어야 합니다."
    }
  ],

  "related_blocks": [
    {
      "block_id": "when_message_cast",
      "relationship": "신호 수신",
      "explanation": "이 블록과 쌍을 이루는 신호를 받는 블록"
    },
    {
      "block_id": "message_cast_wait",
      "relationship": "신호 송신 및 대기",
      "explanation": "신호를 보내고 받는 쪽의 처리가 끝날 때까지 기다리는 블록"
    },
    {
      "block_id": "start_scene",
      "relationship": "장면 전환",
      "explanation": "새로운 장면으로 전환하는 다른 방식의 전역 제어"
    },
    {
      "block_id": "stop_all",
      "relationship": "전역 제어",
      "explanation": "모든 스크립트를 중단하는 강력한 제어 블록"
    }
  ],

  "debugging_tips": [
    {
      "problem": "신호를 보내도 받는 쪽에서 반응하지 않아요",
      "possible_causes": [
        "신호 이름이 보내는 쪽과 받는 쪽이 다름",
        "받는 쪽 오브젝트가 비활성화 상태",
        "받는 쪽에 '신호를 받았을 때' 블록이 없음",
        "신호 보내기 블록이 실제로 실행되지 않음"
      ],
      "solutions": [
        "신호 이름을 정확히 확인하고 대소문자, 띄어쓰기까지 일치시키세요",
        "받는 오브젝트들이 활성 상태인지 확인하세요",
        "모든 수신 오브젝트에 해당 신호를 받는 블록이 있는지 확인하세요",
        "신호 보내기 블록이 실행되는 경로에 있는지 테스트해보세요"
      ]
    },
    {
      "problem": "신호가 너무 많이 보내져서 프로그램이 느려져요",
      "possible_causes": [
        "반복문 안에서 매번 신호를 보냄",
        "신호를 받아서 처리한 후 다시 신호를 보내는 무한 루프",
        "불필요한 곳에서 신호를 계속 보냄"
      ],
      "solutions": [
        "신호를 보내는 조건을 더 구체적으로 설정하세요",
        "신호 흐름을 검토해서 무한 루프가 없는지 확인하세요",
        "정말 필요한 경우에만 신호를 보내도록 최적화하세요"
      ]
    }
  ],

  "real_world_connections": [
    {
      "analogy": "방송국 신호",
      "explanation": "라디오 방송국에서 신호를 보내면 모든 라디오가 동시에 받는 것처럼, 신호도 모든 수신자에게 동시에 전달됩니다."
    },
    {
      "analogy": "화재 경보",
      "explanation": "화재 경보가 울리면 건물의 모든 사람이 동시에 대피하는 것처럼, 신호도 모든 관련 오브젝트가 동시에 반응합니다."
    },
    {
      "analogy": "SNS 알림",
      "explanation": "SNS에 게시물을 올리면 모든 팔로워에게 알림이 가는 것처럼, 신호도 관심 있는 모든 오브젝트에게 전달됩니다."
    }
  ],

  "extensions_and_variations": [
    {
      "concept": "조건부 신호 발송",
      "description": "특정 조건을 만족할 때만 신호를 보내도록 설정",
      "use_case": "플레이어 점수가 100점을 넘었을 때만 '레벨업' 신호 발송"
    },
    {
      "concept": "타이머 기반 신호",
      "description": "정해진 시간마다 주기적으로 신호를 보내는 시스템",
      "use_case": "30초마다 '체력회복' 신호를 보내서 모든 캐릭터 체력 증가"
    },
    {
      "concept": "신호 매개변수",
      "description": "신호와 함께 추가 정보를 전달하는 고급 시스템",
      "use_case": "점수 변경 시 얼마나 변경되었는지 정보도 함께 전달"
    }
  ],

  "broadcasting_strategies": [
    {
      "strategy": "즉시 브로드캐스트",
      "description": "신호를 보내는 즉시 모든 수신자가 동시에 처리",
      "use_case": "게임 시작, 종료 같은 즉각적인 상태 변화"
    },
    {
      "strategy": "지연 브로드캐스트",
      "description": "다른 작업 완료 후 신호를 보내는 방식",
      "use_case": "애니메이션이 끝난 후 다음 단계 신호 발송"
    },
    {
      "strategy": "조건부 브로드캐스트",
      "description": "특정 조건을 확인한 후 신호를 보내는 방식",
      "use_case": "모든 적이 제거되었을 때만 '스테이지 클리어' 신호"
    }
  ],

  "performance_considerations": [
    {
      "aspect": "신호 빈도 관리",
      "description": "너무 자주 신호를 보내면 성능에 영향을 줄 수 있음",
      "tip": "꼭 필요한 경우에만 신호를 사용하고, 간단한 것은 직접 제어"
    },
    {
      "aspect": "수신자 수 고려",
      "description": "같은 신호를 받는 오브젝트가 많을수록 처리 시간 증가",
      "tip": "수신자가 많은 신호는 가벼운 처리만 하도록 설계"
    }
  ],

  "best_practices": [
    {
      "practice": "명확한 신호 명명",
      "description": "신호의 목적과 의미를 쉽게 알 수 있는 이름 사용",
      "example": "'start', 'end', 'update' 대신 'game_start', 'level_end', 'score_update'"
    },
    {
      "practice": "신호 문서화",
      "description": "프로젝트에서 사용하는 모든 신호의 목록과 용도를 정리",
      "example": "주석이나 별도 문서에 신호 이름과 설명 기록"
    },
    {
      "practice": "최소 결합 원칙",
      "description": "오브젝트들이 신호를 통해서만 통신하고 서로 직접 의존하지 않도록 설계",
      "example": "A 오브젝트가 B 오브젝트를 직접 제어하지 않고 신호로 요청"
    }
  ]
}
