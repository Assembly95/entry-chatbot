{
  "id": "message_cast_wait",
  "category": "start",
  "name": "신호 보내고 기다리기",
  "description": "다른 오브젝트들에게 신호를 보내고, 그 신호를 받은 모든 오브젝트의 처리가 완료될 때까지 기다리는 블록입니다. 동기화된 순차 실행을 위한 핵심 블록입니다.",

  "educational_context": {
    "learning_objectives": [
      "동기화 통신 시스템 이해",
      "순차 실행과 병렬 실행의 차이점 학습",
      "오브젝트 간 협력과 대기 메커니즘 습득"
    ],
    "key_concepts": [
      {
        "concept": "동기화 통신",
        "explanation": "신호를 보낸 후 받는 쪽의 모든 처리가 끝날 때까지 기다리는 통신 방식"
      },
      {
        "concept": "블로킹 동작",
        "explanation": "다른 작업이 완료될 때까지 현재 실행을 멈추고 기다리는 것"
      },
      {
        "concept": "순차 실행 보장",
        "explanation": "여러 오브젝트의 동작이 모두 끝난 후에 다음 단계로 진행하는 것"
      },
      {
        "concept": "협력적 실행",
        "explanation": "여러 오브젝트가 함께 작업을 수행하고 완료를 확인하는 시스템"
      }
    ],
    "difficulty_level": "고급",
    "prerequisites": ["기본 신호 송수신 이해", "프로그램 실행 흐름 개념", "동시성과 순차성의 차이 이해"]
  },

  "usage_examples": [
    {
      "title": "단계별 애니메이션",
      "description": "모든 캐릭터가 1단계 동작을 마친 후 2단계 시작",
      "blocks": [
        "message_cast_wait('1단계시작')",
        "speak_something('1단계 완료!')",
        "message_cast_wait('2단계시작')",
        "speak_something('모든 단계 완료!')"
      ],
      "explanation": "모든 오브젝트의 1단계가 끝날 때까지 기다린 후 2단계를 시작합니다."
    },
    {
      "title": "데이터 수집 대기",
      "description": "모든 센서에서 데이터를 받을 때까지 기다림",
      "blocks": [
        "message_cast_wait('데이터수집')",
        "set_variable('모든데이터수집완료', true)",
        "speak_something('분석을 시작합니다')"
      ],
      "explanation": "모든 센서 오브젝트가 데이터 수집을 완료할 때까지 기다린 후 분석을 시작합니다."
    },
    {
      "title": "퍼즐 완성 확인",
      "description": "모든 퍼즐 조각이 제자리에 놓일 때까지 대기",
      "blocks": ["message_cast_wait('퍼즐체크')", "if(get_variable('모든조각완성'))", "start_scene('완성축하')"],
      "explanation": "모든 퍼즐 조각이 위치 확인을 마칠 때까지 기다린 후 완성 여부를 판단합니다."
    }
  ],

  "socratic_questions": [
    {
      "level": "이해",
      "question": "일반 신호 보내기와 신호 보내고 기다리기의 차이점은 무엇인가요?",
      "purpose": "동기와 비동기 통신의 차이점 이해",
      "follow_up": "언제 기다리는 것이 필요하고, 언제 기다리지 않는 것이 좋을까요?"
    },
    {
      "level": "분석",
      "question": "만약 신호를 받은 오브젝트 중 하나가 무한히 실행된다면 어떻게 될까요?",
      "purpose": "블로킹 동작의 위험성과 한계 이해",
      "follow_up": "이런 상황을 어떻게 방지하거나 해결할 수 있을까요?"
    },
    {
      "level": "적용",
      "question": "온라인 협동 게임에서 모든 플레이어가 준비 완료해야 게임이 시작되는 시스템을 만든다면 어떻게 활용할까요?",
      "purpose": "실제 멀티플레이어 시스템에서의 동기화 응용",
      "follow_up": "플레이어가 중간에 나가거나 응답하지 않으면 어떻게 처리해야 할까요?"
    }
  ],

  "common_mistakes": [
    {
      "mistake": "무한 대기 상황 발생",
      "why_it_happens": "신호를 받은 오브젝트가 처리를 완료하지 않거나 무한 루프에 빠짐",
      "consequence": "프로그램이 멈춰서 더 이상 진행되지 않음",
      "solution": "받는 쪽에서 반드시 완료될 수 있는 간단한 동작만 처리하도록 설계",
      "teaching_moment": "모든 친구를 기다리는데 한 명이 안 오면 계속 기다려야 하는 것처럼, 완료가 보장되지 않으면 위험해요."
    },
    {
      "mistake": "불필요한 곳에서 대기 사용",
      "why_it_happens": "모든 신호에 대기를 적용해서 순차 실행하려고 시도",
      "consequence": "프로그램이 느려지고 사용자 경험이 떨어짐",
      "solution": "정말 순서가 중요한 경우에만 대기를 사용하고 나머지는 병렬 실행",
      "teaching_moment": "모든 일을 줄 서서 하나씩 할 필요는 없어요. 동시에 해도 되는 일들이 있어요."
    },
    {
      "mistake": "신호를 받을 오브젝트가 없는 상황에서 대기",
      "why_it_happens": "수신자 없이 신호를 보내고 기다리는 구조",
      "consequence": "즉시 완료되어 대기의 의미가 없어짐",
      "solution": "신호를 받을 오브젝트가 확실히 있는지 미리 확인",
      "teaching_moment": "혼자 있는데 '다들 모였나요?'라고 물어봐도 의미가 없는 것처럼, 받을 사람이 있어야 해요."
    }
  ],

  "step_by_step_guide": [
    {
      "step": 1,
      "title": "동기화 필요성 확인",
      "instruction": "정말로 모든 오브젝트의 완료를 기다려야 하는 상황인지 판단하세요.",
      "visual_hint": "순서가 중요한 경우에만 사용해야 합니다."
    },
    {
      "step": 2,
      "title": "수신 오브젝트들 준비",
      "instruction": "신호를 받을 모든 오브젝트에서 해당 신호를 처리하는 블록을 먼저 만드세요.",
      "visual_hint": "받는 쪽이 준비되지 않으면 무한 대기가 될 수 있습니다."
    },
    {
      "step": 3,
      "title": "송신 오브젝트 선택",
      "instruction": "신호를 보내고 기다릴 오브젝트를 선택하세요.",
      "visual_hint": "보통 메인 컨트롤러나 매니저 역할의 오브젝트입니다."
    },
    {
      "step": 4,
      "title": "신호 카테고리 선택",
      "instruction": "블록 팔레트에서 '신호' 카테고리를 클릭하세요.",
      "visual_hint": "주황색 신호 아이콘이 있는 카테고리입니다."
    },
    {
      "step": 5,
      "title": "대기 블록 찾기",
      "instruction": "'신호 보내고 기다리기' 블록을 찾아 클릭하세요.",
      "visual_hint": "일반 신호 보내기와 비슷하지만 '기다리기'라는 표시가 있습니다."
    },
    {
      "step": 6,
      "title": "신호 이름 설정",
      "instruction": "받는 쪽과 정확히 일치하는 신호 이름을 설정하세요.",
      "visual_hint": "대소문자와 띄어쓰기까지 정확히 일치해야 합니다."
    },
    {
      "step": 7,
      "title": "완료 후 동작 연결",
      "instruction": "모든 처리가 끝난 후 실행할 블록들을 아래에 연결하세요.",
      "visual_hint": "이 블록들은 모든 오브젝트의 처리가 완료된 후에 실행됩니다."
    }
  ],

  "related_blocks": [
    {
      "block_id": "message_cast",
      "relationship": "비동기 신호 송신",
      "explanation": "기다리지 않고 신호를 보내는 빠른 버전"
    },
    {
      "block_id": "when_message_cast",
      "relationship": "신호 수신",
      "explanation": "이 블록이 보낸 신호를 받아 처리하는 블록"
    },
    {
      "block_id": "wait_second",
      "relationship": "시간 대기",
      "explanation": "정해진 시간만큼 기다리는 다른 종류의 대기 블록"
    },
    {
      "block_id": "repeat_until",
      "relationship": "조건 대기",
      "explanation": "특정 조건이 될 때까지 반복하며 기다리는 블록"
    }
  ],

  "debugging_tips": [
    {
      "problem": "신호를 보내고 기다리는데 계속 멈춰있어요",
      "possible_causes": [
        "신호를 받은 오브젝트가 처리를 완료하지 않음",
        "무한 루프나 대기 상태에 빠진 수신 오브젝트",
        "신호를 받을 오브젝트가 비활성화됨",
        "수신 블록에서 오류 발생"
      ],
      "solutions": [
        "각 수신 오브젝트의 처리가 확실히 끝나는지 확인하세요",
        "수신 블록을 간단하게 만들어서 테스트해보세요",
        "모든 수신 오브젝트가 활성 상태인지 확인하세요",
        "수신 블록에서 오류가 없는지 하나씩 확인하세요"
      ]
    },
    {
      "problem": "기다리지 않고 바로 다음으로 넘어가요",
      "possible_causes": [
        "신호를 받을 오브젝트가 아무것도 없음",
        "일반 '신호 보내기' 블록을 사용했음",
        "신호 이름이 일치하지 않아 아무도 받지 않음"
      ],
      "solutions": [
        "해당 신호를 받는 오브젝트가 있는지 확인하세요",
        "'신호 보내고 기다리기' 블록을 사용했는지 확인하세요",
        "신호 이름이 보내는 쪽과 받는 쪽이 정확히 일치하는지 확인하세요"
      ]
    }
  ],

  "real_world_connections": [
    {
      "analogy": "회의실 회의",
      "explanation": "회의에서 '모든 부서 보고서를 준비해주세요'라고 말하면 모든 부서가 준비를 마칠 때까지 기다리는 것과 같습니다."
    },
    {
      "analogy": "오케스트라 지휘",
      "explanation": "지휘자가 신호를 주면 모든 연주자가 동시에 연주하고, 모두 끝날 때까지 기다린 후 다음 악장으로 넘어갑니다."
    },
    {
      "analogy": "단체 사진 촬영",
      "explanation": "'모두 준비되셨나요?'라고 물어보고 모든 사람이 준비를 마칠 때까지 기다린 후 사진을 찍습니다."
    }
  ],

  "extensions_and_variations": [
    {
      "concept": "타임아웃 대기",
      "description": "일정 시간 후에는 완료되지 않아도 다음으로 진행하는 시스템",
      "use_case": "5초 내에 모든 플레이어가 준비하지 않으면 강제로 게임 시작"
    },
    {
      "concept": "부분 완료 허용",
      "description": "전체가 아닌 일정 비율 이상이 완료되면 진행하는 방식",
      "use_case": "80% 이상의 플레이어가 준비되면 게임 시작 허용"
    },
    {
      "concept": "우선순위 대기",
      "description": "중요한 오브젝트의 완료만 기다리고 나머지는 무시",
      "use_case": "핵심 시스템만 완료되면 진행하고 부가 기능은 나중에 처리"
    }
  ],

  "synchronization_patterns": [
    {
      "pattern": "Barrier Synchronization",
      "description": "모든 참여자가 특정 지점에 도달할 때까지 기다리는 동기화",
      "implementation": "신호 보내고 기다리기로 모든 오브젝트의 단계 완료 대기"
    },
    {
      "pattern": "Master-Worker",
      "description": "마스터가 작업을 분배하고 모든 워커의 완료를 기다리는 패턴",
      "implementation": "메인 컨트롤러가 작업 신호를 보내고 모든 워커의 완료 대기"
    },
    {
      "pattern": "Phase Synchronization",
      "description": "단계별로 모든 참여자가 동기화되어 진행하는 패턴",
      "implementation": "각 단계마다 신호 보내고 기다리기로 동기화"
    }
  ],

  "performance_considerations": [
    {
      "aspect": "대기 시간 최소화",
      "description": "수신 오브젝트의 처리를 최대한 간단하게 만들어 대기 시간 단축",
      "tip": "복잡한 처리는 신호 처리와 분리해서 나중에 수행"
    },
    {
      "aspect": "데드락 방지",
      "description": "서로 다른 신호를 기다리며 무한 대기하는 상황 방지",
      "tip": "신호 의존 관계를 미리 설계하고 순환 참조가 없는지 확인"
    },
    {
      "aspect": "시스템 응답성",
      "description": "사용자 입력이나 다른 이벤트가 대기로 인해 차단되지 않도록 주의",
      "tip": "중요한 사용자 인터랙션은 대기 블록과 별도로 처리"
    }
  ],

  "design_guidelines": [
    {
      "guideline": "명확한 완료 조건",
      "description": "각 수신 오브젝트가 언제 처리를 완료하는지 명확히 정의",
      "rationale": "모호한 완료 조건은 무한 대기의 원인이 됨"
    },
    {
      "guideline": "최소 필요 동기화",
      "description": "꼭 필요한 경우에만 동기화를 사용하고 나머지는 비동기로 처리",
      "rationale": "과도한 동기화는 성능 저하와 복잡성 증가를 야기"
    },
    {
      "guideline": "오류 복구 계획",
      "description": "일부 오브젝트가 실패하거나 응답하지 않을 때의 대응 방안 마련",
      "rationale": "견고한 시스템을 위해 예외 상황에 대한 대비 필요"
    }
  ]
}
