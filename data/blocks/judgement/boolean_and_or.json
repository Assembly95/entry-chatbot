{
  "id": "boolean_and_or",
  "category": "judge",
  "name": "[~] [AND/OR] [~]",
  "description": "두 개의 판단 블록을 결합하여 복합 조건을 만드는 블록입니다. '그리고' 연산자는 두 조건이 모두 참일 때만 참이 되고, '또는' 연산자는 두 조건 중 하나만 참이어도 참이 됩니다. 복잡한 조건문을 만들 때 필수적인 논리 연산 블록입니다.",

  "educational_context": {
    "learning_objectives": [
      "논리 연산자의 개념과 종류 이해",
      "복합 조건을 통한 정교한 판단 로직 구현",
      "AND와 OR 연산의 차이점과 활용법 학습",
      "진리표를 통한 논리적 사고력 개발",
      "실생활 조건을 프로그래밍으로 표현하는 능력 향상"
    ],
    "key_concepts": [
      {
        "concept": "논리 연산자(Logical Operator)",
        "explanation": "두 개 이상의 조건을 결합하여 하나의 복합 조건을 만드는 연산자로, 프로그래밍에서 복잡한 판단 로직을 구현하는 핵심 도구"
      },
      {
        "concept": "논리곱(AND, 그리고)",
        "explanation": "두 조건이 모두 참일 때만 참이 되는 논리 연산으로, 모든 조건을 만족해야 하는 엄격한 조건을 만들 때 사용"
      },
      {
        "concept": "논리합(OR, 또는)",
        "explanation": "두 조건 중 하나라도 참이면 참이 되는 논리 연산으로, 여러 가능성 중 하나만 만족해도 되는 유연한 조건을 만들 때 사용"
      },
      {
        "concept": "진리표(Truth Table)",
        "explanation": "논리 연산의 모든 가능한 입력 조합과 그에 따른 결과를 체계적으로 나타낸 표로, 논리 연산을 이해하는 기본 도구"
      }
    ],
    "difficulty_level": "중급",
    "prerequisites": [
      "Entry 기본 인터페이스 사용법",
      "기본 판단 블록들의 이해",
      "조건 블록(만약 ~라면) 사용 경험",
      "비교 연산자 블록 활용 능력",
      "참/거짓 개념의 명확한 이해"
    ]
  },

  "logical_operators": {
    "and_operator": {
      "symbol": "그리고",
      "operator_code": "AND",
      "description": "두 조건이 모두 참일 때만 참을 반환",
      "truth_table": {
        "참 그리고 참": "참",
        "참 그리고 거짓": "거짓",
        "거짓 그리고 참": "거짓",
        "거짓 그리고 거짓": "거짓"
      },
      "characteristics": [
        "모든 조건이 만족되어야 하는 엄격한 조건",
        "하나라도 거짓이면 전체가 거짓",
        "보안이나 안전이 중요한 상황에서 주로 사용",
        "조건이 많을수록 참이 될 확률이 낮아짐"
      ],
      "real_world_examples": [
        "은행 출입: 카드가 있고 그리고 비밀번호가 맞아야 입장",
        "자동차 시동: 키가 꽂혀있고 그리고 안전벨트를 착용해야 시동",
        "게임 레벨업: 경험치가 충분하고 그리고 퀘스트를 완료해야 레벨업"
      ]
    },
    "or_operator": {
      "symbol": "또는",
      "operator_code": "OR",
      "description": "두 조건 중 하나라도 참이면 참을 반환",
      "truth_table": {
        "참 또는 참": "참",
        "참 또는 거짓": "참",
        "거짓 또는 참": "참",
        "거짓 또는 거짓": "거짓"
      },
      "characteristics": [
        "여러 가능성 중 하나만 만족해도 되는 유연한 조건",
        "둘 다 거짓일 때만 전체가 거짓",
        "선택의 여지를 주는 상황에서 주로 사용",
        "조건이 많을수록 참이 될 확률이 높아짐"
      ],
      "real_world_examples": [
        "할인 혜택: VIP 회원이거나 또는 쿠폰이 있으면 할인",
        "출입 허가: 관리자이거나 또는 특별 권한이 있으면 출입 가능",
        "게임 승리: 적을 모두 물리치거나 또는 보물을 찾으면 승리"
      ]
    }
  },

  "usage_examples": [
    {
      "title": "로그인 시스템 - AND 연산",
      "description": "아이디와 비밀번호가 모두 맞아야 로그인 성공",
      "scenario": "보안이 중요한 로그인 기능 구현",
      "blocks": [
        "when_run_button_click",
        "ask_and_wait('아이디를 입력하세요')",
        "set_variable('입력_아이디', <답변>)",
        "ask_and_wait('비밀번호를 입력하세요')",
        "set_variable('입력_비밀번호', <답변>)",
        "if_condition(((<입력_아이디> = 'admin') 그리고 (<입력_비밀번호> = '1234')))",
        "  speak_something('로그인 성공!')",
        "  show('메인화면')",
        "if_condition(((<입력_아이디> != 'admin') 또는 (<입력_비밀번호> != '1234')))",
        "  speak_something('로그인 실패! 다시 시도하세요.')"
      ],
      "explanation": "아이디가 'admin'이고 동시에 비밀번호가 '1234'일 때만 로그인이 성공합니다. 둘 중 하나라도 틀리면 실패합니다."
    },
    {
      "title": "게임 참가 자격 - OR 연산",
      "description": "여러 조건 중 하나만 만족해도 참가 가능",
      "scenario": "유연한 참가 조건을 가진 이벤트",
      "blocks": [
        "when_run_button_click",
        "ask_and_wait('나이를 입력하세요')",
        "set_variable('나이', <답변>)",
        "ask_and_wait('VIP 회원인가요? (예/아니오)')",
        "set_variable('VIP여부', <답변>)",
        "if_condition(((<나이> ≥ (18)) 또는 (<VIP여부> = '예')))",
        "  speak_something('게임 참가 가능합니다!')",
        "  change_variable('참가자수', 1)",
        "if_condition(((<나이> < (18)) 그리고 (<VIP여부> != '예')))",
        "  speak_something('참가 조건을 만족하지 않습니다.')"
      ],
      "explanation": "18세 이상이거나 VIP 회원이면 게임에 참가할 수 있습니다. 둘 중 하나만 만족해도 됩니다."
    },
    {
      "title": "복합 이동 조건 - 혼합 사용",
      "description": "여러 논리 연산자를 조합한 복잡한 조건",
      "scenario": "특정 상황에서만 캐릭터가 이동 가능",
      "blocks": [
        "when_run_button_click",
        "repeat_while_true",
        "  if_condition(((<[스페이스] 키를 눌렀는가?> 그리고 <[위] 키를 눌렀는가?>) 또는 (<마우스를 클릭했는가?> 그리고 (<[에너지]> > (10)))))",
        "    change_y(10)",
        "    change_variable('에너지', -5)",
        "    speak_something('점프!')"
      ],
      "explanation": "스페이스와 위 키를 동시에 누르거나, 마우스를 클릭하면서 에너지가 10 이상일 때 점프합니다."
    },
    {
      "title": "안전 조건 검사 - AND 중심",
      "description": "모든 안전 조건이 만족되어야 실행",
      "scenario": "위험한 작업 전 안전 확인 시스템",
      "blocks": [
        "when_run_button_click",
        "if_condition(((<[벽]에 닿았는가?> = 거짓) 그리고 (<[에너지]> > (50)) 그리고 (<[안전모드]> = 참)))",
        "  speak_something('안전 조건 만족! 작업 시작')",
        "  repeat_basic(10)",
        "    move_direction(5)",
        "    wait_second(0.1)",
        "if_condition(((<[벽]에 닿았는가?> = 참) 또는 (<[에너지]> ≤ (50)) 또는 (<[안전모드]> = 거짓)))",
        "  speak_something('안전 조건 불만족! 작업 중단')",
        "  stop_object('이 스크립트')"
      ],
      "explanation": "벽에 닿지 않고, 에너지가 50 초과이며, 안전모드가 켜져있을 때만 작업을 진행합니다."
    }
  ],

  "progressive_hints": [
    {
      "situation": "언제 '그리고'와 '또는'을 사용하는지 모르겠어요",
      "steps": [
        {
          "step": 1,
          "hint_type": "concept",
          "content": "일상생활을 생각해보세요. '시험 합격을 위해서는 출석일수가 충분하고 그리고 성적이 좋아야 한다'는 모든 조건 만족(그리고), '영화관에 가려면 돈이 있거나 또는 쿠폰이 있으면 된다'는 하나만 만족(또는)해도 되는 상황이에요"
        },
        {
          "step": 2,
          "hint_type": "category",
          "content": "'판단' 카테고리에서 '[~] [그리고/또는] [~]' 블록을 찾아보세요"
        },
        {
          "step": 3,
          "hint_type": "specific_block",
          "content": "가운데 드롭다운을 클릭하면 '그리고'와 '또는' 중에서 선택할 수 있어요"
        }
      ]
    },
    {
      "situation": "복잡한 조건을 만들고 싶은데 어떻게 조합해야 할지 모르겠어요",
      "steps": [
        {
          "step": 1,
          "hint_type": "concept",
          "content": "복잡한 조건은 작은 조건들을 하나씩 만든 후에 논리 연산자로 연결하세요. 예: (A 그리고 B) 또는 (C 그리고 D)"
        },
        {
          "step": 2,
          "hint_type": "specific_block",
          "content": "논리 연산자 블록은 중첩해서 사용할 수 있어요. 하나의 논리 연산자 블록 안에 또 다른 논리 연산자 블록을 넣을 수 있습니다"
        },
        {
          "step": 3,
          "hint_type": "category",
          "content": "괄호 생각하듯이 단계별로 조건을 묶어가며 만들어보세요. 가장 안쪽 조건부터 바깥쪽으로 확장해가면 됩니다"
        }
      ]
    },
    {
      "situation": "조건이 예상대로 동작하지 않아요",
      "steps": [
        {
          "step": 1,
          "hint_type": "concept",
          "content": "진리표를 그려보세요. '참 그리고 거짓 = 거짓', '참 또는 거짓 = 참'인지 확인해보세요"
        },
        {
          "step": 2,
          "hint_type": "specific_block",
          "content": "각각의 작은 조건들이 개별적으로 올바르게 작동하는지 먼저 테스트해보세요"
        },
        {
          "step": 3,
          "hint_type": "category",
          "content": "복잡한 조건을 간단한 조건으로 나누어서 단계별로 확인해보세요"
        }
      ]
    }
  ],

  "common_mistakes": [
    {
      "mistake": "AND와 OR의 의미 혼동",
      "why_it_happens": "일상 언어에서 '그리고'와 '또는'의 모호한 사용으로 인한 개념 혼동",
      "consequence": "의도와 반대되는 조건 로직으로 인한 프로그램 오작동",
      "solution": "진리표를 그려서 각 연산자의 정확한 동작 확인하기",
      "teaching_moment": "수학에서 곱셈(AND)은 엄격하고, 덧셈(OR)은 관대하다고 기억하세요. 곱셈은 하나라도 0이면 0이 되지만, 덧셈은 하나라도 양수면 양수가 되죠."
    },
    {
      "mistake": "복잡한 조건에서 괄호 개념 무시",
      "why_it_happens": "논리 연산의 우선순위를 고려하지 않고 조건을 조합",
      "consequence": "의도하지 않은 조건 조합으로 예상과 다른 결과",
      "solution": "논리 연산자 블록을 중첩해서 명확한 우선순위 표현하기",
      "teaching_moment": "수학에서 괄호로 계산 순서를 정하는 것처럼, 프로그래밍에서도 블록 중첩으로 논리 순서를 정해요."
    },
    {
      "mistake": "부정(NOT) 개념과의 혼동",
      "why_it_happens": "'~이 아니다' 블록과 논리 연산자의 조합에서 드모르간 법칙 미이해",
      "consequence": "조건의 부정을 잘못 표현하여 반대 로직 구현",
      "solution": "'A이고 B가 아니다'와 'A가 아니거나 B가 아니다'의 차이 명확히 하기",
      "teaching_moment": "'모든 학생이 합격한 것은 아니다'와 '어떤 학생도 합격하지 않았다'는 다른 의미예요. 부정의 범위를 정확히 파악해야 해요."
    },
    {
      "mistake": "단락 평가(Short-circuit) 개념 무시",
      "why_it_happens": "논리 연산의 최적화 동작 방식을 모르고 예상과 다른 실행 순서",
      "consequence": "특정 조건이 실행되지 않거나 부작용이 발생",
      "solution": "조건의 순서를 고려하여 중요한 조건을 앞쪽에 배치",
      "teaching_moment": "AND에서 첫 번째가 거짓이면 두 번째는 확인하지 않고, OR에서 첫 번째가 참이면 두 번째는 확인하지 않아요. 효율성을 위한 것이에요."
    }
  ],

  "step_by_step_guide": [
    {
      "step": 1,
      "title": "판단 블록 찾기",
      "instruction": "블록 팔레트에서 '판단' 카테고리를 클릭하세요.",
      "visual_hint": "육각형 모양의 보라색 아이콘을 찾아보세요."
    },
    {
      "step": 2,
      "title": "논리 연산자 블록 선택",
      "instruction": "'[~] [그리고/또는] [~]' 블록을 찾아서 작업 영역으로 드래그하세요.",
      "visual_hint": "양쪽에 판단 블록을 넣는 자리와 가운데 연산자 드롭다운이 있는 육각형 블록이에요."
    },
    {
      "step": 3,
      "title": "연산자 종류 선택",
      "instruction": "가운데 드롭다운을 클릭해서 '그리고' 또는 '또는'을 선택하세요.",
      "visual_hint": "모든 조건이 만족되어야 하면 '그리고', 하나만 만족해도 되면 '또는'을 선택하세요."
    },
    {
      "step": 4,
      "title": "조건 블록 연결",
      "instruction": "양쪽 자리에 결합하고 싶은 판단 블록들을 넣으세요.",
      "visual_hint": "비교 연산자, 센서 블록, 다른 논리 연산자 블록 등을 넣을 수 있어요."
    },
    {
      "step": 5,
      "title": "조건 블록에 연결",
      "instruction": "완성된 논리 연산자 블록을 '만약 ~라면' 블록의 조건 자리에 넣으세요.",
      "visual_hint": "복합 조건이 전체적으로 육각형 모양이 되어 조건 자리에 딱 맞게 들어가요."
    },
    {
      "step": 6,
      "title": "진리표로 검증",
      "instruction": "가능한 모든 경우의 수를 테스트해서 예상한 대로 동작하는지 확인하세요.",
      "visual_hint": "각 조건이 참/거짓일 때의 조합을 모두 확인해보세요."
    }
  ],

  "related_blocks": [
    {
      "block_id": "_if",
      "block_name": "만약 ~라면",
      "relationship": "조건 판단",
      "explanation": "논리 연산자로 만든 복합 조건을 실제 프로그램 흐름 제어에 사용"
    },
    {
      "block_id": "boolean_basic_operator",
      "block_name": "비교 연산자",
      "relationship": "기본 조건 생성",
      "explanation": "논리 연산자로 결합할 기본 조건들을 만드는 블록"
    },
    {
      "block_id": "boolean_not",
      "block_name": "~이 아니다",
      "relationship": "조건 부정",
      "explanation": "논리 연산의 결과를 반대로 뒤집거나 드모르간 법칙 적용"
    },
    {
      "block_id": "reach_something",
      "block_name": "충돌 감지",
      "relationship": "센서 조건",
      "explanation": "논리 연산자와 결합하여 복잡한 상호작용 조건 생성"
    },
    {
      "block_id": "is_press_some_key",
      "block_name": "키 입력 감지",
      "relationship": "입력 조건",
      "explanation": "여러 키나 입력을 동시에 확인하는 복합 입력 조건 생성"
    }
  ],

  "debugging_tips": [
    {
      "problem": "논리 연산 결과가 예상과 달라요",
      "possible_causes": [
        "AND와 OR 연산자를 잘못 선택",
        "개별 조건들이 예상과 다른 결과 반환",
        "논리 연산의 우선순위 오해",
        "진리표에 대한 잘못된 이해"
      ],
      "solutions": [
        "진리표를 그려서 각 경우의 결과 확인하기",
        "개별 조건들을 먼저 따로 테스트해보기",
        "복잡한 조건을 단순한 조건으로 나누어 확인",
        "AND와 OR의 의미 다시 정리하기"
      ]
    },
    {
      "problem": "복합 조건이 너무 복잡해서 이해하기 어려워요",
      "possible_causes": [
        "한 번에 너무 많은 조건을 조합",
        "중첩 구조가 너무 깊음",
        "조건의 논리적 구조가 불명확",
        "변수나 센서 상태가 실시간으로 변함"
      ],
      "solutions": [
        "조건을 작은 단위로 나누어 단계별로 구현",
        "중간 결과를 변수에 저장해서 확인",
        "주석이나 설명을 추가하여 의도 명확화",
        "정적인 값으로 먼저 테스트 후 동적 값 적용"
      ]
    },
    {
      "problem": "조건이 가끔씩만 작동해요",
      "possible_causes": [
        "센서나 입력의 타이밍 문제",
        "변수 값이 예상과 다른 시점에 변경",
        "반복문 안에서 조건이 빠르게 변화",
        "다른 블록의 영향으로 조건 변화"
      ],
      "solutions": [
        "조건 확인 타이밍에 적절한 대기 시간 추가",
        "변수 값을 실시간으로 모니터링하기",
        "조건 확인 빈도 조절하기",
        "조건에 영향을 주는 다른 요소들 파악하기"
      ]
    }
  ],

  "real_world_connections": [
    {
      "analogy": "은행 보안 시스템",
      "explanation": "ATM에서 카드가 있고 그리고 비밀번호가 맞아야 출금할 수 있는 것처럼, 모든 조건이 만족되어야 하는 AND 연산과 같아요."
    },
    {
      "analogy": "교통 신호등",
      "explanation": "보행자 신호가 파란불이거나 또는 차량이 완전히 멈췄을 때 길을 건널 수 있는 것처럼, 하나의 조건만 만족해도 되는 OR 연산과 같아요."
    },
    {
      "analogy": "온라인 쇼핑 할인",
      "explanation": "VIP 회원이거나 또는 쿠폰이 있으면 할인받을 수 있고, 동시에 구매 금액이 5만원 이상이고 그리고 재고가 있어야 주문이 가능한 복합 조건과 같아요."
    },
    {
      "analogy": "스마트폰 잠금 해제",
      "explanation": "지문 인식이나 또는 패턴, 또는 비밀번호 중 하나만 맞으면 되지만, 동시에 화면이 켜져있고 그리고 터치가 가능해야 하는 복합 보안 시스템과 같아요."
    }
  ],

  "extensions_and_variations": [
    {
      "concept": "다중 논리 연산자 조합",
      "description": "3개 이상의 조건을 논리 연산자로 연결하여 더 복잡한 조건 생성",
      "use_case": "(A 그리고 B) 또는 (C 그리고 D) 형태의 복합 조건으로 게임의 승리 조건이나 복잡한 접근 권한 설정"
    },
    {
      "concept": "드모르간 법칙 활용",
      "description": "'~이 아니다' 블록과 조합하여 조건의 부정을 효과적으로 표현",
      "use_case": "'A가 아니고 B가 아니다'를 '(A 또는 B)가 아니다'로 변환하여 더 간단한 조건식 작성"
    },
    {
      "concept": "단락 평가 최적화",
      "description": "조건의 순서를 조정하여 불필요한 계산을 줄이는 효율적인 조건 설계",
      "use_case": "무거운 계산이나 센서 확인을 뒤쪽에 배치하여 성능 향상"
    },
    {
      "concept": "상태 머신 구현",
      "description": "논리 연산자를 활용하여 게임이나 시스템의 복잡한 상태 전환 로직 구현",
      "use_case": "RPG 게임의 캐릭터 상태, 신호등 시스템, 자동 판매기 로직 등"
    }
  ],

  "assessment_criteria": [
    {
      "level": "기초",
      "criteria": "기본적인 AND와 OR 연산자를 사용해서 간단한 복합 조건을 만들 수 있다",
      "example": "나이가 18세 이상이고 그리고 학생증이 있으면 할인, VIP이거나 또는 쿠폰이 있으면 혜택"
    },
    {
      "level": "중급",
      "criteria": "다중 논리 연산자를 조합하여 복잡한 조건문을 설계할 수 있다",
      "example": "게임에서 (레벨이 10 이상이고 아이템을 가지고 있음) 또는 (특별 키를 눌렀고 에너지가 충분함) 조건"
    },
    {
      "level": "고급",
      "criteria": "논리 연산자를 활용하여 정교한 시스템 로직과 상태 관리를 구현할 수 있다",
      "example": "복합 보안 시스템, 다단계 게임 진행 조건, 인공지능 의사결정 트리 구현"
    }
  ],

  "truth_tables": {
    "and_table": {
      "title": "그리고(AND) 진리표",
      "rows": [
        { "조건1": "참", "조건2": "참", "결과": "참", "설명": "둘 다 만족하므로 성공" },
        { "조건1": "참", "조건2": "거짓", "결과": "거짓", "설명": "하나가 불만족하므로 실패" },
        { "조건1": "거짓", "조건2": "참", "결과": "거짓", "설명": "하나가 불만족하므로 실패" },
        { "조건1": "거짓", "조건2": "거짓", "결과": "거짓", "설명": "둘 다 불만족하므로 실패" }
      ]
    },
    "or_table": {
      "title": "또는(OR) 진리표",
      "rows": [
        { "조건1": "참", "조건2": "참", "결과": "참", "설명": "둘 다 만족하므로 성공" },
        { "조건1": "참", "조건2": "거짓", "결과": "참", "설명": "하나가 만족하므로 성공" },
        { "조건1": "거짓", "조건2": "참", "결과": "참", "설명": "하나가 만족하므로 성공" },
        { "조건1": "거짓", "조건2": "거짓", "결과": "거짓", "설명": "둘 다 불만족하므로 실패" }
      ]
    }
  },

  "best_practices": [
    {
      "practice": "조건의 순서 최적화",
      "description": "자주 거짓이 되는 조건을 AND의 앞쪽에, 자주 참이 되는 조건을 OR의 앞쪽에 배치",
      "benefit": "단락 평가로 인한 성능 향상과 불필요한 계산 방지"
    },
    {
      "practice": "복잡한 조건의 단계적 구성",
      "description": "복합 조건을 작은 단위로 나누어 중간 결과를 변수에 저장하거나 별도 블록으로 분리",
      "benefit": "가독성 향상과 디버깅 용이성, 재사용성 증대"
    },
    {
      "practice": "의미 있는 조건 그룹핑",
      "description": "논리적으로 관련된 조건들을 괄호처럼 그룹화하여 명확한 의도 표현",
      "benefit": "코드 이해도 향상과 유지보수성 증대"
    },
    {
      "practice": "부정 조건의 신중한 사용",
      "description": "'~이 아니다' 블록과 논리 연산자 조합 시 드모르간 법칙을 고려한 설계",
      "benefit": "논리 오류 방지와 직관적인 조건문 작성"
    }
  ],

  "performance_tips": [
    {
      "tip": "센서 블록 최적화",
      "description": "무거운 센서나 계산 블록을 논리 연산의 뒤쪽에 배치하여 불필요한 실행 방지",
      "example": "(<간단한_변수_비교> 그리고 <복잡한_거리_계산>) 형태로 구성"
    },
    {
      "tip": "조건 캐싱 활용",
      "description": "반복적으로 사용되는 복잡한 조건의 결과를 변수에 저장하여 재사용",
      "example": "복잡한 권한 확인 결과를 '권한_있음' 변수에 저장 후 여러 곳에서 활용"
    },
    {
      "tip": "중첩 깊이 제한",
      "description": "논리 연산자의 중첩을 3단계 이내로 제한하고, 그 이상은 함수나 별도 블록으로 분리",
      "example": "((A 그리고 B) 또는 (C 그리고 D)) 정도의 복잡성 유지"
    }
  ],

  "common_patterns": [
    {
      "pattern": "범위 조건",
      "structure": "(값 ≥ 최소값) 그리고 (값 ≤ 최대값)",
      "use_case": "나이, 점수, 좌표 등이 특정 범위 내에 있는지 확인"
    },
    {
      "pattern": "다중 선택 조건",
      "structure": "(조건1) 또는 (조건2) 또는 (조건3)",
      "use_case": "여러 가지 방법 중 하나로도 목적을 달성할 수 있는 상황"
    },
    {
      "pattern": "보안 조건",
      "structure": "(인증1 그리고 인증2) 그리고 (권한 확인)",
      "use_case": "2단계 인증이나 다중 보안 검증이 필요한 시스템"
    },
    {
      "pattern": "상태 전환 조건",
      "structure": "(현재_상태 = A) 그리고 ((이벤트1) 또는 (이벤트2))",
      "use_case": "게임 상태, UI 상태, 시스템 모드 변경 조건"
    }
  ],

  "technical_notes": {
    "implementation": {
      "and_function": "leftValue && rightValue (JavaScript 논리곱 연산)",
      "or_function": "leftValue || rightValue (JavaScript 논리합 연산)",
      "type_conversion": "모든 입력값은 Boolean() 함수로 true/false 변환 후 연산"
    },
    "short_circuit_behavior": {
      "and_short_circuit": "첫 번째 조건이 false면 두 번째 조건을 평가하지 않고 false 반환",
      "or_short_circuit": "첫 번째 조건이 true면 두 번째 조건을 평가하지 않고 true 반환"
    },
    "memory_efficiency": [
      "논리 연산자 블록은 메모리 사용량이 적음",
      "중첩된 논리 연산은 스택 깊이를 고려해야 함",
      "복잡한 조건보다는 단순한 조건의 조합이 더 효율적"
    ],
    "debugging_support": [
      "각 조건의 중간 결과를 변수에 저장하여 추적 가능",
      "진리표를 이용한 체계적인 테스트 케이스 작성",
      "논리 연산의 결과를 말하기 블록으로 실시간 확인"
    ]
  }
}
