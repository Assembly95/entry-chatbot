{
  "id": "boolean_not",
  "category": "judge",
  "name": "[~]이(가) 아니다",
  "description": "결합한 판단 블록이 참이면 거짓으로, 거짓이면 참으로 판단하는 블록입니다. 청개구리 같은 블록으로, 기존 조건의 반대 결과를 얻고 싶을 때 사용하는 부정(NOT) 연산자입니다.",

  "educational_context": {
    "learning_objectives": [
      "부정 연산자의 개념과 활용법 이해",
      "논리적 사고에서 부정의 의미와 역할 학습",
      "복잡한 조건에서 부정을 활용한 효율적인 논리 구성",
      "드모르간 법칙의 기본 개념 이해",
      "일상 언어의 부정 표현을 프로그래밍으로 변환하는 능력 개발"
    ],
    "key_concepts": [
      {
        "concept": "부정 연산자(NOT Operator)",
        "explanation": "논리값을 반대로 뒤집는 연산자로, 참을 거짓으로, 거짓을 참으로 변환하는 단항 논리 연산자"
      },
      {
        "concept": "논리적 반전(Logical Inversion)",
        "explanation": "주어진 조건의 반대 상황을 나타내는 논리적 변환으로, '~가 아니다'라는 자연어 표현과 일치"
      },
      {
        "concept": "단항 연산자(Unary Operator)",
        "explanation": "하나의 피연산자만을 필요로 하는 연산자로, 이항 연산자인 AND, OR과 구별되는 특징"
      },
      {
        "concept": "청개구리 로직",
        "explanation": "엔트리에서 부정 블록을 설명할 때 사용하는 직관적 표현으로, 반대로 행동하는 청개구리처럼 조건을 뒤집는 동작"
      }
    ],
    "difficulty_level": "중급",
    "prerequisites": [
      "Entry 기본 인터페이스 사용법",
      "기본 판단 블록들의 이해",
      "조건 블록(만약 ~라면) 사용 경험",
      "비교 연산자와 논리 연산자 기본 이해",
      "참/거짓 개념의 명확한 이해"
    ]
  },

  "not_operator_fundamentals": {
    "basic_operation": {
      "input_true": "거짓으로 변환",
      "input_false": "참으로 변환",
      "function": "입력된 불린 값의 반대값 반환"
    },
    "truth_table": {
      "title": "부정(NOT) 진리표",
      "rows": [
        { "입력": "참", "출력": "거짓", "설명": "참인 조건을 거짓으로 뒤집음" },
        { "입력": "거짓", "출력": "참", "설명": "거짓인 조건을 참으로 뒤집음" }
      ]
    },
    "visual_representation": {
      "block_structure": "[조건 블록] 이(가) 아니다",
      "example": "<마우스를 클릭했는가?> 이(가) 아니다",
      "meaning": "마우스를 클릭하지 않았을 때 참이 됨"
    }
  },

  "usage_examples": [
    {
      "title": "마우스 클릭 외의 상황 감지",
      "description": "마우스를 클릭하지 않은 상태를 감지하여 대기 메시지 표시",
      "scenario": "사용자 상호작용 유도 시스템",
      "blocks": [
        "when_run_button_click",
        "repeat_while_true",
        "  if_condition(<<마우스를 클릭했는가?> 이(가) 아니다>)",
        "    speak_something('마우스를 클릭해주세요!')",
        "    wait_second(2)",
        "  if_condition(<마우스를 클릭했는가?>)",
        "    speak_something('클릭 감지! 게임 시작!')",
        "    stop_repeat()"
      ],
      "explanation": "마우스를 클릭하지 않은 동안 계속해서 안내 메시지를 표시하고, 클릭하면 게임을 시작합니다."
    },
    {
      "title": "충돌하지 않은 상태 확인",
      "description": "벽에 닿지 않은 안전한 상태에서만 이동 허용",
      "scenario": "안전한 이동 제어 시스템",
      "blocks": [
        "when_run_button_click",
        "repeat_while_true",
        "  if_condition((<[위] 키를 눌렀는가?> 그리고 <<[벽]에 닿았는가?> 이(가) 아니다>))",
        "    change_y(10)",
        "    speak_something('안전하게 이동!')",
        "  if_condition((<[위] 키를 눌렀는가?> 그리고 <[벽]에 닿았는가?>))",
        "    speak_something('벽이 있어서 이동할 수 없습니다!')"
      ],
      "explanation": "위 키를 누르고 벽에 닿지 않은 상태일 때만 위로 이동하고, 벽에 닿았으면 경고 메시지를 표시합니다."
    },
    {
      "title": "조건 만족하지 않을 때의 처리",
      "description": "합격 조건을 만족하지 않는 경우 재시험 안내",
      "scenario": "시험 결과 판정 시스템",
      "blocks": [
        "when_run_button_click",
        "ask_and_wait('시험 점수를 입력하세요')",
        "set_variable('점수', <답변>)",
        "if_condition(<점수> ≥ (60))",
        "  speak_something('합격입니다!')",
        "  show('합격증서')",
        "if_condition(<<점수> ≥ (60)> 이(가) 아니다)",
        "  speak_something('불합격입니다. 재시험을 준비하세요.')",
        "  show('재시험안내')"
      ],
      "explanation": "점수가 60점 이상이면 합격, 그렇지 않으면 불합격 처리를 부정 연산자로 명확히 표현합니다."
    },
    {
      "title": "복합 조건의 부정 활용",
      "description": "복잡한 조건을 만족하지 않을 때의 대안 실행",
      "scenario": "게임 특별 조건 미달성 시 일반 모드 실행",
      "blocks": [
        "when_run_button_click",
        "set_variable('특별조건', ((<레벨> > (10)) 그리고 (<아이템수> ≥ (5))))",
        "if_condition(<특별조건>)",
        "  speak_something('특별 모드 시작!')",
        "  start_scene('특별스테이지')",
        "if_condition(<<특별조건> 이(가) 아니다>)",
        "  speak_something('일반 모드로 진행합니다.')",
        "  start_scene('일반스테이지')"
      ],
      "explanation": "복합 조건을 변수에 저장한 후, 그 조건을 만족하지 않을 때 다른 경로로 진행하도록 설계합니다."
    }
  ],

  "progressive_hints": [
    {
      "situation": "언제 '~이 아니다' 블록을 사용하는지 모르겠어요",
      "steps": [
        {
          "step": 1,
          "hint_type": "concept",
          "content": "일상에서 '비가 오지 않으면 소풍을 간다'처럼 어떤 조건이 만족되지 않을 때 행동하고 싶은 상황에 사용해요"
        },
        {
          "step": 2,
          "hint_type": "category",
          "content": "'판단' 카테고리에서 '[~] 이(가) 아니다' 블록을 찾아보세요"
        },
        {
          "step": 3,
          "hint_type": "specific_block",
          "content": "기존 조건 블록을 이 블록 안에 넣으면 그 조건의 반대 상황을 확인할 수 있어요"
        }
      ]
    },
    {
      "situation": "부정 블록을 사용했는데 예상과 다른 결과가 나와요",
      "steps": [
        {
          "step": 1,
          "hint_type": "concept",
          "content": "부정은 정확히 반대로 뒤집는 것이에요. '참'이 '거짓'으로, '거짓'이 '참'으로 바뀝니다"
        },
        {
          "step": 2,
          "hint_type": "specific_block",
          "content": "안에 넣은 조건 블록이 올바르게 작동하는지 먼저 따로 확인해보세요"
        },
        {
          "step": 3,
          "hint_type": "category",
          "content": "복잡한 조건에 부정을 적용할 때는 드모르간 법칙을 생각해보세요: '(A 그리고 B)가 아니다' = 'A가 아니다 또는 B가 아니다'"
        }
      ]
    },
    {
      "situation": "부정을 써야 할지 다른 방법을 써야 할지 모르겠어요",
      "steps": [
        {
          "step": 1,
          "hint_type": "concept",
          "content": "'만약 A라면 ~ 아니면 ~' 블록과 '만약 A가 아니라면' 블록은 목적이 달라요. 두 경우 모두 처리하려면 전자를, 아닌 경우만 처리하려면 후자를 사용하세요"
        },
        {
          "step": 2,
          "hint_type": "specific_block",
          "content": "코드가 더 읽기 쉬운 방향을 선택하세요. 때로는 부정보다 직접적인 조건이 더 명확할 수 있어요"
        },
        {
          "step": 3,
          "hint_type": "category",
          "content": "성능상 차이는 거의 없으니 의미가 더 명확한 방법을 선택하세요"
        }
      ]
    }
  ],

  "common_mistakes": [
    {
      "mistake": "이중 부정 사용",
      "why_it_happens": "복잡한 논리를 표현하려다가 부정을 두 번 사용하게 됨",
      "consequence": "원래 조건과 같아져서 불필요하게 복잡한 코드 생성",
      "solution": "이중 부정은 원래 조건과 같으므로 부정 블록을 제거하고 단순화하기",
      "teaching_moment": "'비가 오지 않는 것이 아니다'는 결국 '비가 온다'와 같은 의미예요. 이중 부정은 피하는 것이 좋아요."
    },
    {
      "mistake": "드모르간 법칙 무시",
      "why_it_happens": "복합 조건에 부정을 적용할 때 논리 법칙을 잘못 이해",
      "consequence": "의도하지 않은 논리 구조로 인한 프로그램 오작동",
      "solution": "'(A 그리고 B)가 아니다'를 'A가 아니다 또는 B가 아니다'로 정확히 변환하기",
      "teaching_moment": "'둘 다 하지 않는다'와 '둘 중 하나라도 하지 않는다'는 다른 의미예요. 부정의 범위를 정확히 파악해야 해요."
    },
    {
      "mistake": "가독성을 해치는 부정 남용",
      "why_it_happens": "모든 조건을 부정으로 표현하려고 하거나 불필요한 부정 사용",
      "consequence": "코드 이해가 어려워지고 유지보수성 저하",
      "solution": "자연스럽고 직관적인 조건 표현 우선, 꼭 필요한 경우만 부정 사용",
      "teaching_moment": "'키가 크지 않다'보다는 '키가 작다'가 더 자연스러운 표현이에요. 긍정적 표현을 우선 고려해보세요."
    },
    {
      "mistake": "부정 조건과 else 블록의 혼동",
      "why_it_happens": "'만약 ~라면, 아니면' 구조와 '만약 ~가 아니라면' 구조의 차이를 모름",
      "consequence": "같은 기능을 다른 방식으로 구현하여 일관성 부족",
      "solution": "목적에 따라 적절한 구조 선택: 양쪽 모두 처리할 때는 if-else, 부정 조건만 처리할 때는 not 사용",
      "teaching_moment": "'if-else'는 갈래길에서 양쪽 방향을 모두 정해놓는 것이고, 'not'은 특정 상황이 아닐 때만 반응하는 것이에요."
    }
  ],

  "step_by_step_guide": [
    {
      "step": 1,
      "title": "판단 블록 찾기",
      "instruction": "블록 팔레트에서 '판단' 카테고리를 클릭하세요.",
      "visual_hint": "육각형 모양의 보라색 아이콘을 찾아보세요."
    },
    {
      "step": 2,
      "title": "부정 블록 선택",
      "instruction": "'[~] 이(가) 아니다' 블록을 찾아서 작업 영역으로 드래그하세요.",
      "visual_hint": "가운데에 판단 블록을 넣는 자리가 있고 '이(가) 아니다'라는 텍스트가 있는 육각형 블록이에요."
    },
    {
      "step": 3,
      "title": "조건 블록 연결",
      "instruction": "부정하고 싶은 조건 블록을 부정 블록의 가운데 자리에 넣으세요.",
      "visual_hint": "비교 연산자, 센서 블록, 다른 논리 연산자 블록 등을 넣을 수 있어요."
    },
    {
      "step": 4,
      "title": "논리 확인",
      "instruction": "원래 조건과 부정된 조건의 의미를 명확히 파악하세요.",
      "visual_hint": "예: '마우스를 클릭했는가?'의 부정은 '마우스를 클릭하지 않았을 때'를 의미해요."
    },
    {
      "step": 5,
      "title": "조건문에 연결",
      "instruction": "완성된 부정 블록을 '만약 ~라면' 블록의 조건 자리에 넣으세요.",
      "visual_hint": "부정된 조건이 참일 때(즉, 원래 조건이 거짓일 때) 실행될 블록들을 안에 배치하세요."
    },
    {
      "step": 6,
      "title": "테스트 및 검증",
      "instruction": "의도한 대로 부정 조건이 작동하는지 다양한 상황에서 테스트하세요.",
      "visual_hint": "원래 조건이 참일 때와 거짓일 때 모두 확인해보세요."
    }
  ],

  "related_blocks": [
    {
      "block_id": "_if",
      "block_name": "만약 ~라면",
      "relationship": "조건 판단",
      "explanation": "부정 연산자로 만든 조건을 실제 프로그램 흐름 제어에 사용"
    },
    {
      "block_id": "if_else",
      "block_name": "만약 ~라면, 아니면",
      "relationship": "대안 구조",
      "explanation": "부정 블록의 대안으로 사용할 수 있는 양방향 조건문"
    },
    {
      "block_id": "boolean_and_or",
      "block_name": "그리고/또는",
      "relationship": "복합 조건",
      "explanation": "드모르간 법칙을 통해 부정과 조합하여 복잡한 조건 표현"
    },
    {
      "block_id": "boolean_basic_operator",
      "block_name": "비교 연산자",
      "relationship": "기본 조건",
      "explanation": "부정할 기본 조건을 제공하는 블록"
    },
    {
      "block_id": "reach_something",
      "block_name": "충돌 감지",
      "relationship": "센서 조건",
      "explanation": "'닿지 않았을 때'와 같은 부정 상황을 표현하기 위해 함께 사용"
    }
  ],

  "debugging_tips": [
    {
      "problem": "부정 블록이 예상과 반대로 작동해요",
      "possible_causes": [
        "부정의 의미를 잘못 이해",
        "안에 들어간 조건 블록이 잘못 작동",
        "이중 부정 구조 사용",
        "논리적 사고의 혼동"
      ],
      "solutions": [
        "안에 들어간 조건을 먼저 단독으로 테스트해보기",
        "진리표를 그려서 예상 결과와 실제 결과 비교하기",
        "말로 조건을 표현해보고 논리적 구조 확인하기",
        "이중 부정이 있는지 블록 구조 검토하기"
      ]
    },
    {
      "problem": "복합 조건에 부정을 적용했는데 이상해요",
      "possible_causes": [
        "드모르간 법칙을 잘못 적용",
        "부정의 범위를 잘못 설정",
        "논리 연산자의 우선순위 오해",
        "복잡한 조건의 논리 구조 파악 실패"
      ],
      "solutions": [
        "복합 조건을 단순한 조건으로 분해하여 각각 확인",
        "드모르간 법칙 적용: '(A∧B)의 부정 = (A의 부정)∨(B의 부정)'",
        "괄호를 사용하여 부정의 범위 명확히 하기",
        "각 부분의 참/거짓 값을 표로 정리해보기"
      ]
    },
    {
      "problem": "부정 조건이 가끔씩만 작동해요",
      "possible_causes": [
        "원래 조건의 상태가 예상과 다르게 변화",
        "타이밍 문제로 인한 조건 변화",
        "다른 블록의 영향으로 조건 상태 변경",
        "센서나 입력의 불안정한 동작"
      ],
      "solutions": [
        "원래 조건의 상태를 실시간으로 모니터링하기",
        "조건 확인 타이밍에 적절한 대기 시간 추가",
        "부정 조건에 영향을 주는 다른 요소들 파악",
        "안정적인 조건으로 먼저 테스트해보기"
      ]
    }
  ],

  "real_world_connections": [
    {
      "analogy": "신호등 시스템",
      "explanation": "'빨간불이 아니면 건널 수 있다'처럼 특정 상태가 아닐 때의 행동 규칙과 같아요."
    },
    {
      "analogy": "보안 시스템",
      "explanation": "'허가되지 않은 접근'을 감지하는 것처럼 정상이 아닌 상황을 탐지하는 시스템과 같아요."
    },
    {
      "analogy": "자동차 경고등",
      "explanation": "'연료가 충분하지 않을 때' 경고등이 켜지는 것처럼 정상 상태가 아닐 때 알림을 주는 것과 같아요."
    },
    {
      "analogy": "온라인 게임 대기실",
      "explanation": "'게임이 시작되지 않았을 때' 대기 상태를 유지하는 것처럼 특정 조건이 만족되지 않을 때의 상태 관리와 같아요."
    }
  ],

  "advanced_concepts": [
    {
      "concept": "드모르간 법칙 (De Morgan's Laws)",
      "description": "논리곱과 논리합의 부정을 상호 변환하는 법칙",
      "rules": [
        "'(A 그리고 B)가 아니다' = '(A가 아니다) 또는 (B가 아니다)'",
        "'(A 또는 B)가 아니다' = '(A가 아니다) 그리고 (B가 아니다)'"
      ],
      "practical_use": "복잡한 조건의 부정을 더 간단하고 이해하기 쉬운 형태로 변환"
    },
    {
      "concept": "부정 정규형 (Negation Normal Form)",
      "description": "모든 부정 연산자가 기본 명제에만 적용되도록 변환하는 형태",
      "benefit": "복잡한 논리식을 표준화하여 이해와 최적화를 쉽게 만듦",
      "example": "'((A 그리고 B)가 아니다)'를 '(A가 아니다) 또는 (B가 아니다)'로 변환"
    },
    {
      "concept": "조건부 부정 (Conditional Negation)",
      "description": "특정 상황에서만 부정을 적용하는 고급 논리 구조",
      "implementation": "if-else 구조와 부정을 조합하여 상황별 다른 부정 로직 구현",
      "use_case": "게임에서 모드별로 다른 승리 조건의 부정 적용"
    }
  ],

  "best_practices": [
    {
      "practice": "긍정적 조건 우선 고려",
      "description": "가능하면 긍정적인 조건을 먼저 생각하고, 꼭 필요한 경우에만 부정 사용",
      "benefit": "코드 가독성 향상과 논리적 사고의 명확성"
    },
    {
      "practice": "복잡한 부정 조건의 단순화",
      "description": "드모르간 법칙을 활용하여 복잡한 부정 조건을 더 간단한 형태로 변환",
      "benefit": "이해하기 쉽고 유지보수가 용이한 코드 작성"
    },
    {
      "practice": "부정 조건의 명확한 주석",
      "description": "부정을 사용한 조건의 의도와 의미를 명확히 설명하는 주석 추가",
      "benefit": "다른 사람이나 나중에 다시 보았을 때 빠른 이해 가능"
    },
    {
      "practice": "테스트 케이스의 완전성",
      "description": "부정 조건을 사용할 때 모든 경우의 수(참/거짓)를 테스트",
      "benefit": "예상치 못한 논리 오류 방지와 신뢰성 있는 프로그램 구현"
    }
  ],

  "assessment_criteria": [
    {
      "level": "기초",
      "criteria": "기본적인 부정 연산자를 사용해서 간단한 조건의 반대 상황을 표현할 수 있다",
      "example": "마우스를 클릭하지 않았을 때 안내 메시지 표시, 키를 누르지 않은 상태에서 대기"
    },
    {
      "level": "중급",
      "criteria": "복합 조건에 부정을 적용하고 드모르간 법칙을 이해하여 논리적으로 올바른 조건을 구성할 수 있다",
      "example": "복잡한 게임 규칙의 예외 상황 처리, 다중 조건을 만족하지 않을 때의 대안 로직 구현"
    },
    {
      "level": "고급",
      "criteria": "부정 연산자를 효율적으로 활용하여 명확하고 유지보수 가능한 논리 구조를 설계할 수 있다",
      "example": "상태 머신에서 예외 상태 처리, 복합 보안 조건의 부정을 통한 접근 제어 시스템, 인공지능 의사결정에서 제외 조건 설정"
    }
  ],

  "technical_notes": {
    "implementation": {
      "function": "!script.getBooleanValue('VALUE', script)",
      "description": "JavaScript의 논리 부정 연산자(!)를 사용하여 불린 값을 반전",
      "type_conversion": "입력값을 Boolean() 함수로 변환 후 부정 연산 적용"
    },
    "performance": {
      "computational_cost": "매우 낮음 - 단순한 비트 연산으로 처리",
      "memory_usage": "추가 메모리 사용 없음",
      "optimization": "컴파일러 수준에서 최적화되는 기본 연산"
    },
    "edge_cases": [
      "undefined나 null 값은 false로 변환되어 부정 시 true 반환",
      "빈 문자열('')과 숫자 0은 false로 변환되어 부정 시 true 반환",
      "모든 다른 값들은 true로 변환되어 부정 시 false 반환"
    ]
  },

  "common_patterns": [
    {
      "pattern": "예외 상황 처리",
      "structure": "if (조건이 아니다) { 예외_처리(); }",
      "use_case": "정상 조건을 만족하지 않을 때의 에러 처리나 대안 실행"
    },
    {
      "pattern": "대기 상태 유지",
      "structure": "while (시작조건이 아니다) { 대기_메시지(); }",
      "use_case": "특정 조건이 만족될 때까지 대기하는 루프"
    },
    {
      "pattern": "안전 조건 확인",
      "structure": "if (위험조건이 아니다) { 안전한_작업(); }",
      "use_case": "위험하지 않은 상황에서만 작업을 수행하는 안전 시스템"
    },
    {
      "pattern": "상태 반전",
      "structure": "새상태 = 현재상태가_아니다",
      "use_case": "ON/OFF, 보이기/숨기기 같은 토글 기능 구현"
    }
  ],

  "debugging_checklist": [
    {
      "item": "안에 들어간 조건이 올바르게 작동하는지 확인",
      "method": "부정 블록에서 조건을 빼내어 별도로 테스트"
    },
    {
      "item": "부정의 의미가 의도한 바와 일치하는지 확인",
      "method": "자연어로 조건을 설명해보고 논리적 타당성 검증"
    },
    {
      "item": "이중 부정이나 불필요한 복잡성이 있는지 확인",
      "method": "블록 구조를 단순화할 수 있는지 검토"
    },
    {
      "item": "드모르간 법칙이 올바르게 적용되었는지 확인",
      "method": "복합 조건의 부정을 단계별로 분해하여 검증"
    },
    {
      "item": "모든 가능한 경우에 대해 테스트했는지 확인",
      "method": "참/거짓 모든 경우의 수에 대한 체계적 테스트"
    }
  ],

  "learning_progression": [
    {
      "stage": "기본 이해",
      "skills": ["부정 연산자의 기본 개념 파악", "간단한 조건의 부정 적용", "진리표 읽기와 이해"],
      "activities": ["기본 센서 조건의 부정 연습", "마우스 클릭 여부의 부정 활용", "키 입력 상태의 부정 확인"]
    },
    {
      "stage": "응용 단계",
      "skills": ["복합 조건에 부정 적용", "드모르간 법칙의 기본 이해", "if-else와 부정의 차이점 파악"],
      "activities": ["AND/OR 조건에 부정 적용 연습", "복잡한 게임 규칙의 예외 상황 구현", "안전 조건 시스템 설계"]
    },
    {
      "stage": "고급 활용",
      "skills": ["효율적인 논리 구조 설계", "가독성을 고려한 부정 사용", "상태 머신에서의 부정 활용"],
      "activities": ["복잡한 시스템의 예외 처리 로직 구현", "AI 의사결정에서 제외 조건 설정", "최적화된 조건문 구조 설계"]
    }
  ],

  "troubleshooting_guide": [
    {
      "symptom": "부정 블록이 항상 참 또는 항상 거짓을 반환해요",
      "diagnosis": [
        "안에 들어간 조건이 상수값(항상 참 또는 항상 거짓)인지 확인",
        "조건 블록이 제대로 연결되지 않았을 가능성 검토",
        "변수나 센서 상태가 예상과 다를 가능성 확인"
      ],
      "solution": [
        "안에 들어간 조건을 동적으로 변하는 조건으로 교체",
        "블록 연결 상태를 다시 확인하고 재연결",
        "변수값이나 센서 상태를 실시간으로 모니터링"
      ]
    },
    {
      "symptom": "복합 조건의 부정이 예상과 달라요",
      "diagnosis": ["드모르간 법칙 적용 오류 가능성", "논리 연산자의 우선순위 혼동", "부정의 적용 범위 설정 오류"],
      "solution": [
        "드모르간 법칙에 따라 단계별로 변환",
        "괄호를 사용하여 연산 순서 명확화",
        "복잡한 조건을 단순한 조건으로 분해하여 확인"
      ]
    }
  ],

  "extension_activities": [
    {
      "activity": "논리 퍼즐 게임",
      "description": "부정 연산자를 활용한 논리 퍼즐 만들기",
      "learning_goal": "복잡한 논리 관계에서 부정의 역할 이해",
      "implementation": "여러 조건의 부정을 조합하여 특정 상황만 만족하는 퍼즐 구성"
    },
    {
      "activity": "상태 기반 게임",
      "description": "게임 캐릭터의 상태가 특정 조건이 아닐 때의 행동 구현",
      "learning_goal": "상태 머신에서 부정 조건의 활용법 습득",
      "implementation": "캐릭터가 공격중이 아닐 때, 이동중이 아닐 때 등의 조건으로 다양한 행동 제어"
    },
    {
      "activity": "안전 시스템 시뮬레이션",
      "description": "여러 안전 조건이 만족되지 않을 때 경고하는 시스템",
      "learning_goal": "실제 시스템에서 부정 조건의 중요성 이해",
      "implementation": "온도, 압력, 속도 등이 정상 범위에 있지 않을 때 알람 시스템 구현"
    }
  ]
}
